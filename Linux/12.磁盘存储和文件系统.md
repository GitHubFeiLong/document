

lsmod

lsblk -f查看分区

blkid 查看分区和文件系统类型

tune2fs -l /dev/sda1 查看块设备的元数据(创建文件系统之后使用)

init 1 单用户

init 3 字符

init 5图形

## 2.2 文件系统

### **2.2.1 文件系统概念**

文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构;即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统。

从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩,加密等

支持的文件系统:

```bash
/lib/modules/`uname -r`/kernel/fs
```

各种文件系统：[https://wiki.deepin.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F](https://wiki.deepin.org/wiki/文件系统)

帮助：man 5 fs

### 2.2.2文件系统类型

```
#查看文件系统类型
df -T
```



**Linux常用文件系统**

<table>
    <tr>
    	<td>ext2</td>
        <td>Extended file system 适用于那些分区容量不是太大，更新也不频繁的情况，列如/boot 分区</td>
    </tr>
    <tr>
    	<td>ext3</td>
        <td>是ext2的改进版本，其支持日志功能，能够帮助系统从非正常关机导致的异常中恢复</td>
    </tr>
    <tr>
    	<td>ext4</td>
        <td>是ext文件系统的最新版，提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件（16TB），最大1EB的文件系统，以及速度的提升</td>
    </tr>
    <tr>
    	<td>xfs</td>
        <td>SGI，支持最大8EB的文件系统</td>
    </tr>
    <tr>
    	<td>swap</td>
        <td>交换分区，虚拟内存</td>
    </tr>
    <tr>
    	<td>iso9660</td>
        <td>光盘</td>
    </tr>
    <tr>
    	<td>btrfs</td>
        <td>Oracle</td>
    </tr>
    <tr>
    	<td>relserfs</td>
        <td></td>
    </tr>
</table>

**Windows 常用文件系统**

<table>
    <tr>
    	<td>FAT32</td>
        <td></td>
    </tr>
    <tr>
    	<td>NTFS</td>
        <td></td>
    </tr>
    <tr>
    	<td>exFAT</td>
        <td></td>
    </tr>
</table>

**Unix**

<table>
    <tr>
    	<td>FFS</td>
        <td>fast</td>
    </tr>
    <tr>
    	<td>UFS</td>
        <td>unix</td>
    </tr>
    <tr>
    	<td>IFS2</td>
        <td></td>
    </tr>
</table>

**网络文件系统**

<table>
    <tr>
    	<td>NFS</td>
        <td></td>
    </tr>
    <tr>
    	<td>CIFS</td>
        <td></td>
    </tr>
</table>

**集群文件系统**

<table>
    <tr>
    	<td>GFS2</td>
        <td></td>
    </tr>
    <tr>
    	<td>OCFS2</td>
        <td>Oracle</td>
    </tr>
</table>

**分布式文件系统**

<table>
    <tr>
    	<td>fastdfs</td>
        <td></td>
    </tr>
    <tr>
    	<td>ceph</td>
        <td></td>
    </tr>
    <tr>
    	<td>moosefs</td>
        <td></td>
    </tr>
    <tr>
    	<td>mogilefs</td>
        <td></td>
    </tr>
    <tr>
    	<td>glusterfs</td>
        <td></td>
    </tr>
    <tr>
    	<td>Lustre</td>
        <td></td>
    </tr>
</table>

**RAW**

​	未经处理，或者未经格式化产生的文件系统

**常用的文件系统特性**

<table>
    <tr>
    	<td>FAT32</td>
        <td>最多只能支持16TB的文件系统和4GB的文件</td>
    </tr>
    <tr>
    	<td>NTFS</td>
        <td>最多只能支持16EB的文件系统和16EB的文件</td>
    </tr>
    <tr>
    	<td>EXT3</td>
        <td>1.最多只能支持32TB的文件系统和2TB的文件，实际只能容纳2TB的文件系统和16GB的文件<br>
        2.Ext3目前只支持32000个子目录<br>
        3.Ext3文件系统使用32位空间记录块数量和inode数量<br>
        4.当数据写入到Ext3文件系统中时，Ext3的数据块分配器每次只能分配一个4KB的块    
        </td>
    </tr>
    <tr>
    	<td>EXT4</td>
        <td>1.EXT4是Linux系统下的日志文件系统，是EXT3文件系统的后继版本<br>
        2.EXT4的文件系统容量达到1EB，而支持单个文件则达到16TB<br>
        3.理论上支持无限数量的子目录<br>
        4.EXT4文件系统使用64位空间记录块数量和inode数量<br>
        5.EXT4的多块分配器支持一次调用分配多个数据块
        <br>
        6.修复速度更快    
        </td>
    </tr>
    <tr>
    	<td>XFS</td>
        <td>1.根据所记录的日志在很短的时间内迅速恢复磁盘文件内容<br>
        2.用优化算法，日志记录对整体文件操作影响非常小
        <br>3.是一个全64-bit的文件系统，最大可以支持8EB的文件系统，而支持单个文件则达到8EB
        <br>4.能以接近裸设备I/O的性能存储数据</td>
    </tr>
</table>

目前支持的文件系统：

```bash
cat /proc/filesystems
```



### 2.2.3 文件系统的组成部分

```bash
#查看已经加载在内存中的文件系统
lsmod
```



+ 内核中的模块：ext4，xfs，vfat
+ Linux的虚拟文件系统：VFS
+ 用户矿建的管理工具：mkfs.ext4, mkfs.xfs, mkfs.vfat

![1585101527020](..\\typora-user-images\1585101527020.png)



### 2.2.4 文件系统选择管理

#### 2.2.4.1 创建文件系统

**创建文件管理工具**

<table>
    <tr>
        <td rowspan="2">mkfs命令</td>
        <td>mkfs.FS_TYPE /dev/DEVICE
        <br>ext4
        <br>xfs
        <br>btrfs
        <br>vfat</td>
    </tr>
    <tr>
        <td>mkfs -t FS_TYPE /dev/DEVICE
        <br>-L 'LABEL' 设定卷标</td>
    </tr>
    <tr>
    	<td>mke2fs</td>
        <td>ext系列文件系统专用管理工具</td>
    </tr>
</table>

**常用选项**

<table style="width:100%">
    <tr>
    	<td style="width:45%;">-t {ext2|ext3|ext4}</td>
        <td>指定文件系统类型</td>
    </tr>
     <tr>
    	<td>-b {1024|2048|4096}</td>
        <td>指定块大小</td>
    </tr>
     <tr>
    	<td>-L 'LABEL'</td>
        <td>设置卷标</td>
    </tr>
     <tr>
    	<td>-j</td>
        <td>相当于 -t ext3，mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3</td>
    </tr>
     <tr>
    	<td>-i #</td>
        <td>为数据空间中每多少个字节创建一个inode；不应该小于block大小</td>
    </tr>
     <tr>
    	<td>-N #</td>
        <td>指定分区中创建多少个inode</td>
    </tr>
     <tr>
    	<td>-l</td>
        <td>一个inode记录占用的磁盘空间大小，128...4096</td>
    </tr>
     <tr>
    	<td>-m #</td>
        <td>默认5%，为管理人员预留空间占总空间的百分比</td>
    </tr>
     <tr>
    	<td>-O FEATURE[.....]</td>
        <td>启用指定特性</td>
    </tr>
    <tr>
    	<td>-O ^FEATURE[.....]</td>
        <td>关闭指定特性</td>
    </tr>
</table>



#### 2.2.4.2 查看和管理分区信息



<table>
    <tr>
    	<td>查看块设备属性信息</td>
        <td>blkid</td>
    </tr>
    <tr>
    	<td>格式</td>
        <td>blkid [OPTION]...[DEVICE]</td>
    </tr>
    <tr>
    	<td  rowspan="2">常用选项</td>
        <td>-U UUID	根据指定的UUID来查找对应的设备</td>
    </tr>
    <tr>
        <td>-L LABEL	根据指定的LABEL来查找对应的设 </td>
</tr>
 </table>



<table>
    <tr>
    	<td>e2label</td>
        <td>管理ext系列文件系统的LABEL</td>
    </tr>
    <tr>
    	<td>格式</td>
        <td>e2label DEVICE [LABEL]</td>
    </tr>
</table>



<table>
    <tr>
    	<td>findfs</td>
        <td>查找分区</td>
    </tr>
    <tr>
        <td rowspan="2">格式</td>
    	<td>findfs [options] LABEL=label</td>
    </tr>
    <tr>
    	<td>findfs [options] UUID=uuid</td>
    </tr>
</table>



<table>
    <tr>
    	<td>tune2fs</td>
        <td>重新设定ext系列文件系统可调整参数的值</td>
    </tr>
    <tr>
    	<td rowspan="10">常用选项</td>
        <td>-l 查看指定文件系统超级块信息：super block</td>
    </tr>
    <tr>
    	<td>-L 'LABEL' 修改卷标</td>
    </tr>
    <tr>
    	<td>-m # 修改留给管理员的空间百分比</td>
    </tr>
    <tr>
    	<td>-j 将ext2升级为ext3</td>
    </tr>
    <tr>
    	<td>-O 文件系统属性启用或禁用，-O ^has_journal</td>
    </tr>
    <tr>
    	<td>-o  调整文件系统的默认挂载选项，-o ^acl</td>
    </tr>
    <tr>
    	<td>-U UUID 修改UUID号</td>
    </tr>
</table>



<table>
     <tr>
    	<td>dumpe2fs</td>
         <td> 显示ext文件系统信息，将磁盘块分组管理</td>
    </tr>
    <tr>
        <td>选项</td>
    	<td>-h 查看超级块信息，不显示分组信息</td>
    </tr>
    </table>





<table>
     <tr>
    	<td>xfs_info</td>
         <td>显示已挂载的xfs文件系统信息</td>
    </tr>
    <tr>
    	<td>格式</td>
        <td>xfs_info mountpoint | devname</td>
    </tr>
</table>









**超级块个INODE TABLE**

![1585185647810](..\\typora-user-images\1585185647810.png)



**2.2.4.3 文件系统检测和修复**

文件系统夹故障常发生于死机或者正常关机之后，挂载为文件系统标记为“no clean”

注意：一定不要在挂载状态下执行命令修复。

**fsck**:File  System Check

```bash
fsck.FS_TYPE
fsck -t FS_TYPE
```

注意：FS_TYPE 一定要与分区上已经文件类型相同

常用选项：

+ -a	自动修复
+ -r     交互式修复错误



**e2fsck**：ext系列文件专用的检测修复工具

+  -y	自动回答为yes
+ -f      强制修复
+ -p    自动进行安全的修复文件系统问题



**xfs_repair**:xfs文件系统专用检测修复工具

常用选项：

+ -f    修复文件而设备
+ -n    只检查
+ -d    允许修复只读的挂载设备，在单用户下修复时使用，然后立即reboot



### 2.3 挂载

挂载：将额外文件系统与根文件系统某现存的目录建立关联关系，进而使得此目录作为其它文件访问入口的行为。

卸载：为解除此关联关系的过程



把设备关联挂载点：mount Point

挂载点下原有文件在挂载完成后会被临时隐藏，因此，挂载点目录一般为空

进程正在使用中的设备无法被挂载

#### 2.3.1 挂载文件系统 mount

格式：

```bash
mount [-fnrsvw] [-t vfstype] [-o options] device dir
```

device：指明要挂载的设备

+ 设备文件：例如/dev/sda5
+ 卷标：-L ‘LABEL’，例如-L ‘MYDATA’
+ UUID：-U ‘UUID’ 例如 -U ‘fa846700-2ffa-41f8-85d9-0f47152f051e’
+ 为文件系统名称：proc,sysfs，devtmpfs，configfs

dir：挂载点

​	事先存在，建议使用空目录

mount常用命令选项

<table style="width:100%">
    <tr>
    	<td style="width:30%">-t vsftype</td>
        <td>指定要挂载的设备上的文件系统类型</td>
    </tr>
    <tr>
    	<td>-r</td>
        <td>readonly,只读挂载</td>
    </tr>
    <tr>
    	<td>-w</td>
        <td>read and write,读写挂载</td>
    </tr>
    <tr>
    	<td>-n</td>
        <td>不更新/etc/mtab,mount不可见</td>
    </tr>
    <tr>
    	<td>-a</td>
        <td>自动挂载所有支持自动挂载的设备（定义在了/etc/fstab文件中，且挂载选项中有auto功能）</td>
    </tr>
    <tr>
    	<td>-L 'LABEL'</td>
        <td>以卷标指定挂载设备</td>
    </tr>
    <tr>
    	<td>-U 'UUID'</td>
        <td>以UUID指定要挂载的设备</td>
    </tr>
    <tr>
    	<td>-B， --bind</td>
        <td>绑定目录到另一个目录上</td>
    </tr>
    <tr>
    	<td rowspan="15">-o options</td>
        <td>（挂载文件系统的选项）多个选项使用逗号分隔</td>
    </tr>
    <tr>
        <td>async:异步模式（内存更改时，写入缓存区buffer，过一段时间再写到磁盘中）；sync同步模式，内存更改时，同时写磁盘</td>
    </tr>
    <tr>
        <td>atime/noatime:包含目录和文件</td>
    </tr>
    <tr>
        <td>diratime/nodiratime：目录的访问时间戳</td>
    </tr>
    <tr>
        <td>auto/noauto:是否支持自动挂载，是否支持-a选项</td>
    </tr>
    <tr>
        <td>exec/noexec:是否支持将文件系统上运行应用程序</td>
    </tr>
    <tr>
        <td>dev/nodev:是否支持在此文件系统上使用设备文件</td>
    </tr>
    <tr>
        <td>suid/nosuid:是否支持suid和sgid权限</td>
    </tr>
    <tr>
        <td>remount:重新挂载</td>
    </tr>
    <tr>
        <td>ro:只读；rw：读写</td>
    </tr>
    <tr>
        <td>user/nouser:是否允许普通用户挂载此设备，/etc/fstab使用</td>
    </tr>
    <tr>
        <td>acl:启用此文件系统上的acl功能</td>
    </tr>
    <tr>
        <td>loop：启用loop设备</td>
    </tr>
    <tr>
        <td>_netdev:当网络可用时才对网络资源进行挂载，如：NFS文件系统</td>
    </tr>
    <tr>
        <td>defaults：相当于rw，suid，dev,exec,auto,nouser,async</td>
    </tr>
</table>

**挂载规则：**

+ 一个挂载点同一时间只能挂载一个设备
+ 一个挂载点同一时间挂载了多个设备，只能看到最后一个设备的数据，其它设备上的数据将被隐藏
+ 一个设备可以同时挂载到多个挂载点
+ 通常一个挂载点一般是已存在的空的目录



#### 2.3.2 卸载文件系统 umount

卸载时：可使用设备，也可以使用挂载点

```bash
umount 设备名 | 挂载点
```

#### 2.3.3 查看挂载情况

查看挂载

```bash
#通过查看/etc/mtab 文件显示当前已挂载的所有设备
mount
# 查看内核追踪到的已挂载的所有设备
cat /proc/mounts
```

查看挂载点情况

```bash
findmnt MOUNT_POINT | device
```

查看正在访问指定文件系统的进程

```bash
lsof MOUNT_POINT
fuser -v MOUNT_POINT
```

终止所有正在访问指定的文件系统的进程

```bash
fuser -km MOUNT_POINT
```



### 2.3.4 持久挂载

将挂载保存到 /etc/fstab 中可以下次开机时，自动启用挂载

/etc/fstab 格式：man 5 fstab

每行定义一个要挂载的文件系统，其中包括6项

1.要挂载的设备或伪文件系统

​	设备文件

​		LABEL：LABEL=“”

​		UUID：UUID=“”

​		伪文件系统名称：proc,sysfs

2.挂载点：必须是事先存在的目录

3.文件系统类型：ext4，xfs,iso9660,nfs,none

4.挂载选项：defaults,acl,bind

5.转储频率：0：不做备份；1：每天转储；2：每隔一天转储

6.fsck检查的文件系统的顺序：允许的数字是0 1 2

​	0：不自检；1：首先自检，一般只有rootfs采用；2：非rootfs使用



添加新的挂载项，需要执行下面的命令生效

```bash
mount -a
mount -o remount /mnt/sda6
```



## 2.4  处理交换文件和分区

### 2.4.1 swap介绍

swap交换分区是系统RAM的补充，swap分区支持虚拟内存。当没有猪狗的RAM保存系统处理的数据时，会将数据写入swap分区，当系统缺乏swap空间时，内核会因RAM内存耗尽而终止进程。配置过多swap空间会造成存储设备处于分配状态但闲置，造成浪费，过多swap空间还会掩盖内存泄漏

注意：为优化性能，可以将swap分区分布存放，或高性能磁盘存放

官方推荐系统swap空间

<table>
    <thead>
    	<th>系统中的RAM量</th>
        <th>推荐的swap空间</th>
        <th>允许休眠的建议swap空间大小</th>
    </thead>
    <tbody>
    	<tr>
        	<td>低于2GB</td>
            <td>RAM 量的倍数</td>
            <td>RAM 容量的三倍</td>
        </tr>
        <tr>
        	<td>2GB - 8GB</td>
            <td>等于RAM量</td>
            <td>RAM 容量的倍数</td>
        </tr>
        <tr>
        	<td>8GB - 64GB</td>
            <td>4GB到RAM容量的0.5倍</td>
            <td>RAM 容量的1.5倍</td>
        </tr>
        <tr>
        	<td>超过64GB</td>
            <td>独立负载（至少4GB）</td>
            <td>不建议使用休眠功能</td>
        </tr>
    </tbody>
</table>



### 2.4.2 交换分区实现过程

1.创建交换分区或者文件

2.使用mkswap写入特殊签名

3.在/etc/fstab文件中添加适当的条目

4.使用swapon -a 激活交换空间

启用swap分区

```bash
swapon [OPTION] ... [DEVICE]
```

**SWAP的优先级**

可以指定swap分区0到32767的优先级，值越大优先级越高；如果用户没有指定，那么核心会自动给swap指定一个优先级，这个优先级从-1开始，每加入一个新的没有用户指定优先级的swap，会给这个优先级减一。

先添加的swap的缺省优先级比较高，除非用户自己指定一个优先级，而用户指定的优先级（是正数）永远高于核心缺省指定的优先级（是负数）

**swap的使用策略**

/proc/sys/vm/swappiness 的值决定了当内存占用达到一定的百分比时，会启用swap分区的空间

范例：

```bash
[root@centos7: ~]# cat /proc/sys/vm/swappiness
30
```

说明：内存正在使用到100-30=70%的时候，就开始出现交换分区的使用。简单地说这个参数定义了系统对swap的使用倾向，默认值为30，值越大表示越倾向于使用swap。可以设为0，这样做并不会禁止对swap的使用，只是最大限度地降低了使用swap的可能性

范例：创建swap分区

```bash
[root@centos7: ~]# echo -e 'n\np\n\n\n+2G\nt\n82\n\w\n' | fdisk /dev/sdc
[root@centos7: ~]#mkswap /dev/sdc1
#添加
[root@centos7: ~]#vim /etc/fstab
#生效
[root@centos7: ~]#swapon -a
[root@centos7: ~]#cat /proc/swap
```



```bash
swapon -s
# 全部禁用
swapoff -a
```



## 2.5 移动介质

挂载意味着使外来的文件系统看起来如同是主目录树的一部分，所有移动介质也需要挂载，挂载点通常在/media或mnt下

访问前，介质必须被挂载

摘除时，介质必须被卸载

按照默认设置，非根用户只能挂载某些设备（光盘、DVD、软盘、USB等等）



### 2.5.1 使用光盘

在图形环境下自动启动挂载/run/media/<user>/<label>

手工挂载

```bash
mount /dev/cdrom /mnt/
```

操作光盘

```bash
eject 弹出光盘
eject -t 弹入光盘
```

创建ISO文件

```bash
cp /dev/cdrom /root/centos.iso
mkisofs -r -o /root/etc.iso /etc
```

刻录光盘

```bash
wodim -v -eject centos.iso
```



### 2.5.2 USB介质

查看USB设备是否识别

```bash
lsusb
```

被内核探测为SCSI设备

/dev/sdaX、/dev/sdbX或类似的设备文件

在图形环境中自动挂载在/run/media/<user>/<label>

手动挂载

```bash
mount /dev/sdx# /mnt
```



## 2.6 磁盘常见工具

### 2.6.1 文件系统空间占用等信息的查看工具 df

```bash
df [OPTION] ... [FILE] ...
```

常用选项

```bash
-H：以10为单位
-T：文件系统类型
-h：human-readable
-i：inodes instead of blocks
-p：以Posix兼容的格式输出
```



### 2.6.2 查看某目录总体空间占用状态 du

```bash
du [OPTION]...DIR
```

常用选项

```bash
-h；human-readable
-s：summary
--max-depth=#：指定最大目录层级
```



### 2.6.3 工具 dd

dd命令：convert and copy a file

格式：

```bash
dd if=/PATH/FROM/SRC of=/PATH/TO/DEST bs=# count=# skip=# seek=#
```

<table style="width:100%">	
<tr>
    	<td style="width:30%">if=file</td>
        <td>从所命名文件读取而不是从标准输入</td>
    </tr>
    <tr>
    	<td>of=file</td>
        <td>写到所命名的文件而不是到标准输出</td>
    </tr>
    <tr>
    	<td>ibs=size</td>
        <td>一次读size个byte</td>
    </tr>
     <tr>
    	<td>obs=size</td>
        <td>一次写size个byte</td>
    </tr>
    <tr>
    	<td>bs=size</td>
        <td>	block size，指定块大小（既是ibs也是obs）</td>
    </tr>
    <tr>
    	<td>cbs=size</td>
        <td>一次转化size个byte</td>
    </tr>
    <tr>
    	<td>count=n</td>
        <td>复制n个bs</td>
    </tr>
    <tr>
    	<td>skip=n</td>
        <td>跳过if源（input file）n个字符</td>
    </tr>
     <tr>
    	<td>seek=n</td>
        <td>跳过of源（output file）n个字符</td>
    </tr>
     <tr>
    	<td>conv=conversion<br>[,conversion...]</td>
        <td>用指定的参数转换文件</td>
    </tr>
    <tr>
    	<td rowspan="10">conversion</td>
        <td>转换参数</td>
    </tr>
    <tr>
        <td>ascii 转换EBCDIC为ASCII</td>
    </tr>
    <tr>
        <td>ebcdic 转换ASCII为EBCDIC</td>
    </tr>
    <tr>
        <td>lcase 把大写字符转换为小写字符</td>
    </tr>
     <tr>
        <td>ucase 把小写字符转换为大写字符</td>
    </tr>
    <tr>
        <td>nocreat 不创建输出文件</td>
    </tr>
    <tr>
        <td>noerror 出错时不停止</td>
    </tr>
    <tr>
        <td>notrunc 不截短输出文件</td>
    </tr>
    <tr>
        <td>sync 把每个输入快填充到libs个字节，不足部分用空（NUL）字符补齐</td>
    </tr>
    <tr>
        <td>fdatasync 写完成前，物理写入输出文件</td>
    </tr>
</table>



范例：

```bash
#备份MBR
dd if=/dev/sda of=/tmp/mbr.bak bs=512 count=1

#破环MBR中的boot loader
dd if=/dev/zero of=/dev/sda bs=64 count=1 seek=446

#有一个大于2k的二进制文件fileA。现在想从第64个字节位置开始读取，需要读取的大小是128bytes。又有fileB，想把上面弄读取到的128Bytes写到32个字节开始的位置，替换128Bytes，实现如下
dd if=fileA of=fileB bs=1 count=128 skip=63 seek=31 conv=notrunc

#将本地的/dev/sdx整盘备份到 /dev/sdy
dd if=/dev/sdx of=/dev/sdy

#将/dev/sdx全盘数据备份到指定路径的image文件
dd if=/dev/sdx of=/path/to/image

#备份/dev/sdx全盘数据，并利用gzip压缩，保存到指定路径
dd if=/dev/sdx | gzip > /path/to/image.gz

#将备份文件恢复到指定盘
dd if=/path/to/image of=/dev/sdx

#将压缩的备份文件恢复到指定盘
gzip -dc /path/to/image.gz | dd of=/dev/sdx

#将内存里的数据拷贝到root目录下的mem.bin文件
dd if=/dev/mem of=/root/mem.bin bs=1024

#拷贝光盘数据到root文件夹下，并保存为drrom.iso文件
dd if=/dev/cdrom of=/root/cdrom.iso

#销毁磁盘数据
dd if/dev/urandom of=/dev/sda1

#通过比较dd指令输出中命令的执行时间，即可确定系统最佳的block size 大小
dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000
dd if=/dev/zero of=/root/1Gb.file bs=2048 count=500000
dd if=/dev/zero of=/root/1Gb.file bs=4096 count=250000

#出硬盘写速度
dd if=/dev/zero of=/root/1Gb.file bs=1024 count=1000000

#测试硬盘读速度
dd if=/root/1Gb.file bs=64k | dd of=/dev/null
```

练习：

1.创建一个2G的文件系统，块大小为2048Byte，预留1%可用空间，文件系统ext4，卷标为TEST，要求次分区开机后自动挂载至/test目录，且默认有acl挂载选项

2.写一个脚本，完成如下功能：

​	（1）列出当前系统识别到的所有磁盘设备

​	（2）如磁盘数量为1，则显示其空间使用信息；否则，则显示最后一个磁盘上的空间使用



# 3 RAID

## 3.1 什么是RAID

RAID：Redundant Arrays of Inexpensive (independent) Disks

1988年由加利福尼亚大学克利分校（University of California-Berkeley）“A Case for Redundant ” Arryas of Inexpensive Disks"

多个磁盘合成一个“阵列”来提供更好的性能，冗余，或者两者都提供

![1585269325505](..\typora-user-images\1585269325505.png)

**RAID**

提高IO能力：磁盘并行读写

提高耐用性：磁盘冗余来实现

级别：多块磁盘组织在一起的工作方式有所不同

**RAID实现的方式**

+ 外接式磁盘阵列：通过扩展卡提供适配能力

+ 内接式RAID：主板集成RAID控制器，安装OS前在BIOS里配置

+ 软件RAID：通过OS实现



## 3.2 RAID级别

RAID-0：条带卷，strip

RAID-1：镜像卷，mirror

RAID-2

...

RAID-5

RAID-6

RAID-10

RAID-01

RAID级别

​	

### 3.2.1 RAID-0

以chunk为单位，读写数据

![1585269875617](..\typora-user-images\1585269875617.png)

读写性能提升

可用空间：N*min（s1,s2...）

无容错能力

最少磁盘数：2，2+



### 3.2.2 RAID-1



![1585270227707](..\typora-user-images\1585270227707.png)

读性能提升，写性能略有下降

可用空间1*min(s1,s2...)

有个冗余能力

最少磁盘数：2,2N



### 3.2.3 RAID-4

多块数据盘异或运算值存于专用校验盘

磁盘利用率(N-1)/N

有冗余能力

至少三块硬盘才可以实现



### 3.2.4 RAID-5

![1585270465235](..\typora-user-images\1585270465235.png)

读写性能提升

可用空间(N-1)*min(s1,s2,..)

有容错能力，允许最多一块磁盘损坏

最少磁盘数：3，3+



### 3.2.5 RAID-6

![1585270848402](..\typora-user-images\1585270848402.png)

读、写性能提升

可用空间：(N-2)*min(S1,S2...)

有容错能力：允许最多2块磁盘损坏

最少磁盘数：4，4+



### 3.2.6 RAID-10

![1585270973388](..\typora-user-images\1585270973388.png)

读写性能提升

可用空间 N*min(S1,S2...)/2

有容错能力：每组镜像最多只能坏一块

最少磁盘数：4，4+



### 3.2.7 RAID-01

![1585271096600](..\typora-user-images\1585271096600.png)

多块磁盘先实现RAID0，再组合成RAID1



### 3.2.8 RAID-50

![1585271374839](..\typora-user-images\1585271374839.png)

多块磁盘先实现RAID5，再组合成RAID0



### 3.2.9 其它级别

JBOD：Just a Bunch Of Disks

![1585271492279](..\typora-user-images\1585271492279.png)

功能：将多块磁盘的空间合并一个大的连续空间使用

可用空间：sum(S1,S2...)



**RAID7**

​	可以理解为一个独立存储计算机，自身 带有操作系统和管理工具，可以独立运行，理论上性能最高的RAID模式

常用级别：

RAID-0，RAID-1，RAID-5，RAID-10，RAID-50，JBOD



## 3.3 实现软RAID



# 4 逻辑卷管理器（LVM）

## 4.1 LVM介绍

LVM：Logical Volume Manager 可以允许对卷进行方便操作的抽象层，包括重新设定文件系统的大小，允许在多个物理设备间重新组织文件系统

LVM可以弹性的更改LVM的容量

![1585271964549](..\typora-user-images\1585271964549.png)

通过交换PE来进行资料的转换，将原来LV内的PE转移到其它的设备中以降低LV的容量，获将其他设备中的PE加到LV中以加大容量

实现过程

+ 将设备指定为物理卷
+ 用一个或者多个物理卷来创建一个卷组，物理卷是用固定大小的物理区域（Physical Extent ,PE）来定义的。
+ 在物理卷上创建的逻辑卷，是由物理区域（PE）组成