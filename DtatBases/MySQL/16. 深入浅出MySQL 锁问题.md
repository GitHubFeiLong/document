# 16. 深入浅出MySQL 锁问题		

​		锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（如CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题。锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 16.1 MySQL锁概述

​		相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM 和 MEMORY的存储引擎采用的是表级锁；InnoDB 存储引擎既支持行级锁（row-level locking）,也支持表级锁，但默认情况下是采用行级锁。

​		MySQL这3种锁的特性可大致归纳如下。

+ 表级锁：开销小，加锁快；不会出现死锁；锁粒度大，发生锁冲突的概率最高，并发度最低。
+ 行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生锁冲突的概率最低，并发度最高。
+ 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁粒度介于表级锁和行级锁之间，并发度一般。

​		从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说那种锁更合适。仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如 web 应用；而行级锁则适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。下面重点介绍MySQL表锁和InnoDB行锁的问题。由于BDB已经被InnoDB 取代，即将称为历史，这里就不再讨论。

## 16.2 MyISAM 表锁

​		MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。随着应用对事物完整性和并发性要求的不断提高，MySQL才开始开发基于事务的存储引擎，后来慢慢出现了支持页锁的BDB存储引擎和支持行锁的InnoDB 存储引擎。但是，MyisAM 的表锁依然是使用最为广泛的锁类型。本节讲详细介绍MyisAM 表锁的使用。

### 16.2.1 查询表级锁争用情况

​		可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定争用情况。

```mysql
mysql> show status like 'table%';
+----------------------------+-------+
| Variable_name              | Value |
+----------------------------+-------+
| Table_locks_immediate      | 2     |
| Table_locks_waited         | 0     |
| Table_open_cache_hits      | 0     |
| Table_open_cache_misses    | 0     |
| Table_open_cache_overflows | 0     |
+----------------------------+-------+
5 rows in set (0.00 sec)
```

​		如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况。

### 16.2.2 MySQL 表级锁的锁模式

