# Java内存模型

java内存模型（JMM），线程间通信
JMM：可见性、原子性、有序性
冯诺依曼理论模型
Arm X86
intel core (不同型号) amd

## 多级缓存

cpu多级缓存中，最小存储单位---》缓存行（inttFlag) 大小是64字节or128字节or32字节

## 摩尔定律 

18个月CPU性能提高一倍
JMM模型是抽象的概念，描述的是多线程与内存间的通信，Java线程内存模型与CPU缓存模型类似，他是标准化的，用于屏蔽掉各种硬件和操作系统的内存访问差异。
**volatile** 关键字,解决可见性

## JMM -8大数据原子操作

1.lock（锁定）：作用于主内存额变量，把一个变量标记为一条线程独占状态。
2.unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3.read(读取）：把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
4.load（载入）：它把read操作从主内存中得到的变量值放入到工作内存的变量副本中
5.use(使用)：它把工作内存中的一个变量值传递给执行引擎
6.assign（赋值）：它把一个从执行引擎接收到的值赋给工作内存的变量。
7.store（存储）：把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
8.write（写入）：把store操作从工作内存中的一个变量的值传送到主内存的变量中。

## 发消息总线写，总线嗅探机制。

volatile依赖总线锁

### 1.总线加锁（性能很低）

CPU从主存读取数据到缓存区当中，总线会加锁锁定主存区域，来自其他CPU或者总线代理的控制请求将被阻塞，无法读写该数据直到锁定被释放

### 2.MESI缓存一致性协议

多CPU从主存读取同一数据到各自缓存区中，该数据在lock前缀指令（汇编指令）执行期间已经在处理器内部的缓存中被锁定，缓存被锁定期间其他CPU无法读写该数据，直到该缓存数据被修改同步到主存后，其他CPU通过总线嗅探机制感知数据变化及时失效自己缓存中的数据，在下一轮指令周期从主存重新load数据。
Volatile可见性实现原理：
JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步回主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。
底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”
	a.缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据（MESI协议）
	b.一个处理器的缓存会写到内存，内存会导致其他处理器的缓存无效（MESI协议）IA-32架构

## MESI：

M 修改
E 独占
S 共享
I 失效	
如果有多个线程同时写时，由总线决定。
如果变量大小超过了缓存行大小：

Volatile是虚拟机提供的轻量级的同步机制，它具备两种特性：保证共享变量对所有线程的可见性；禁止指令重排序优化，保证有序性；

synchorized