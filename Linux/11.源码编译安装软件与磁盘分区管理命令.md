开源源代码获取方式：http://apache.org/

编译源码的项目工具：

+ C、C++ 的源码编译：使用make项目管理器

  configure脚本 --> Makefile.in -- > Makefile

  相关开发工具：

  autoconf:生成configure脚本

  automake:生成Makefile.in

+ Java的源码编译，使用maven

## C语言源代码编译安装过程

利用编译工具，通常只需要三个大步骤

+ ./configure

  (1)通过选项传递参数，指定安装路径，启用特性等；执行时会参考用户的指定以及Makefile.in文件生成Makefile

  (2)检查依赖到的外部环境，如依赖的软件包

+ make 根据Makefile文件，构建应用程序
+ make install 复制文件到相应路径

注意：安装前可以通过查看README，INSTALL获取帮助

#### 编译安装准备

准备：安装相关的依赖包

+ 开发工具：make，gcc(c/c++编译器GNU C Complier)
+ 开发环境：开发库（glibc：标准库），头文件，可安装开发包组Development Tools
+ 特定软件相关依赖包

生产实践：基于最小化安装的系统建议安装下面相关包

```
yum install gcc make gcc-c++ glibc glibc-devel pcre pcre-devel openssl openssl-devel systemd-devel zlib-devel vim lrzsz tree tmux lsof tcpdump wget net-tools iotop bc bzip2 zip unzip nfs-utils man-pages
```

## 编译安装

第一步：运行 configure脚本，生成Makefile文件

其选项主要功能：

+ 可以指定安装位置
+ 指定启用的特性

获取其支持使用的选项

```
./configure --help
```

选项分类：

+ 安装路径设定：

  + --prefix=/PATH:指定默认安装位置，默认为/usr/local/

  + --sysconfdir=/PATH:配置文件安装位置

    System types：支持交叉编译

+ 软件特性和相关指定：

  Optional Features：可选特性

  ​	--disable-FEATURE

  ​	--enable-FEATURE[=ARG]

  Optional Packages:可选包

  ​	--with-PACKAGE[=ARG] 依赖包

  ​	--widthout-PACKAGE 禁用依赖关系

  注意：通常编译操作以来的程序包，需要安装此程序报的开发“组件”，其包名一般类似于name-devel-VERSION

第二步：make

第三步：make install

#### 安装后的配置

​	1.二进制程序目录导入至PATH环境变量中

​		编辑文件/etc/profile.d/NAME.sh

```
export PATH=/PATH/TO/BIN:$PATH
```

​	2.相关用户及文件

​		有些开源软件编译完成后，还需要创建相关的用户及文件

​	3.导入帮助手册

​		编辑/etc/man.config|man_db.conf文件，添加一个MANPATH

​	范例：编译安装tree1.8

```bash
#1 安装相关的依赖包
[root@centos7: ~]yum install gcc make

#2 下载源码并解压
[root@centos7: src]tar -zxvf tree-1.8.0.tgz

#3 进入解压缩的目录，查看README和INSTALL
[root@centos7: src]cd tree-1.8.0
[root@centos7: tree-1.8.0]cat README
[root@centos7: tree-1.8.0]cat INSTALL

#4 修改源码的版本号
[root@centos7: tree-1.8.0]#grep -R 'v1\.8\.0' *
tree.c:static char *version ="$Version: $ tree v1.8.0 (c) 1996 - 2018 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro $";
tree.c:static char *hversion="\t\t tree v1.8.0 %s 1996 - 2018 by Steve Baker and Thomas Moore <br>\n"

[root@centos7: tree-1.8.0]sed -i 's#v1\.8\.0#v.18.0#' tree.c

#5 编译准备
[root@centos7: tree-1.8.0]vim Makefile
prefix=/apps/tree

#6 编译
[root@centos7: tree-1.8.0]make

#7 安装
[root@centos7: tree-1.8.0]make install

#8 修改PATH变量
[root@centos7: tree-1.8.0]echo 'PATH=/apps/tree/bin:$PATH' > /etc/profile.d/tree.sh
. /etc/profile.d/tree.sh

#9 验证
[root@centos7: tree-1.8.0]tree --version
```

范例：编译安装cmatrix

```bash
#1 下载cmatrix压缩包，解压进入目录
[root@centos7: src]#wget https://www.asty.org/cmatrix2/dist/cmatrix-1.2a.tar.gz
[root@centos7: src]#tar xvf cmatrix-1.2a.tar.gz
[root@centos7: src]#cd cmatrix-1.2a/

#2 执行./configure make make install 进行安装
[root@centos7: cmatrix-1.2a]#./configure --prefix=/apps/cmatrix
[root@centos7: cmatrix-1.2a]#make
[root@centos7: cmatrix-1.2a]#make install
## 注意：如果./configure未提示库未安装，在make时提示需要头文件(*.h),使用yum list *name* 来搜索，然后安装name-devel的开发包，然后重新解压编译安装

#3 添加到环境变量PATH中
[root@centos7: cmatrix-1.2a]#echo 'PATH=/apps/cmtrix/bin:$PATH' > /etc/profile.d/cmtrix.sh
[root@centos7: cmatrix-1.2a]#. /etc/profile.d/cmtrix.sh

#4 测试
[root@centos7: profile.d]#cmatrix
```

范例：编译安装httpd

​	安装相关依赖：

```bash
# 下载必须的apr 和 apr-util包,解压
[root@centos7: src]#https://mirrors.tuna.tsinghua.edu.cn/apache/apr/apr-1.7.0.tar.bz2
[root@centos7: src]#https://mirrors.tuna.tsinghua.edu.cn/apache/apr/apr-util-1.6.1.tar.bz2
[root@centos7: src]#tar jxvf apr-1.7.0.tar.bz2
[root@centos7: src]#tar jxvf apr-util-1.6.1.tar.bz2

# 安装apr 和 apr-util
## 安装apr [如果报错，自己百度（我这里报错，百度了下，需要去configure文件将$RM "$cfgfile" 注释掉）]
[root@centos7: src]#cd apr-1.7.0/
[root@centos7: apr-1.7.0]#./configure --prefix=/apps/apr1.7
[root@centos7: apr-1.7.0]#make && make install
## 安装apr-util
[root@centos7: apr-1.7.0]#cd ../apr-util-1.6.1/
[root@centos7: apr-util-1.6.1]#cd apr-1.7.0/
[root@centos7: apr-util-1.6.1]#./configure --prefix=/apps/apr-util1.6 --with-apr=/apps/apr1.7
# 如果[yum install expat-deve -y]出错找不到包，执行[yum clean all] 然后在创建缓存 [yum makecache]
[root@centos7: apr-util-1.6.1]#yum install expat-deve -y
[root@centos7: apr-util-1.6.1]#./configure --prefix=/apps/apr-util1.6 --with-apr=/apps/apr1.7
[root@centos7: apr-util-1.6.1]#make && make install

```



```bash

# 下载，解压,进入目录
[root@centos7: src]#wget https://downloads.apache.org//httpd/httpd-2.4.41.tar.bz2
[root@centos7: src]#tar xjfv  httpd-2.4.41.tar.bz2
[root@centos7: src]#cd httpd-2.4.41/

# 查看README，INSTALL文档
[root@centos7: httpd-2.4.41]#cat README
[root@centos7: httpd-2.4.41]#cat INSTALL

# 查看软件特性：
##Optional Features:--disable-FEATURE(默认是开启的特性，编译时加上参数关闭该特性)；--enable-FEATURE[=ARG](默认是关闭的，编译时加上参数开启该特性)
[root@centos7: httpd-2.4.41]#./configure --help

# 编译安装
## 2选1，如果没有执行“安装相关依赖：”就不带两个--with-apr=/apps/apr1.7 --with-apr-util=/apps/aprutil1.6
[root@centos7: httpd-2.4.41]#./configure --prefix=/apps/httpd --sysconfdir=/etc/httpd24 --enable-so --enable-ssl
## 根据“安装相关依赖：”指定apr和apr-util的包位置
[root@centos7: httpd-2.4.41]#./configure --prefix=/apps/httpd --sysconfdir=/etc/httpd24 --enable-so --enable-ssl --with-apr=/apps/apr1.7 --with-apr-util=/apps/aprutil1.6
......
checking for APR... no
configure: error: APR not found.  Please read the documentation.

# 报错 error: APR not found，查询apr包（只列apr未装的包）
[root@centos7: httpd-2.4.41]#yum list  available "*apr*"
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
Available Packages
apr-devel.x86_64                                 1.4.8-3.el7_4.1                   cd  
apr-util-devel.x86_64                            1.5.2-6.el7                       cd  
....
# 安装
[root@centos7: httpd-2.4.41]#yum install apr-devel.x86_64

# 第二次编译
[root@centos7: httpd-2.4.41]#./configure --prefix=/apps/httpd --sysconfdir=/etc/httpd24 --enable-so --enable-ssl
......
checking for APR-util... no
configure: error: APR-util not found.  Please read the documentation.
# 安装
[root@centos7: httpd-2.4.41]#yum install apr-util-devel.x86_64

# 交叉编译(期间可能会出现差包，复制错误信息到百度解决问题)
[root@centos7: httpd-2.4.41]#make -j 2
[root@centos7: httpd-2.4.41]#make install

# 添加环境变量
[root@centos7: httpd-2.4.41]#echo 'PATH=/apps/httpd/bin:$PATH'  > /etc/profile.d/httpd.sh
[root@centos7: httpd-2.4.41]#. /etc/profile.d/httpd.sh 
#启动和停止默认是80端口使用ip访问
[root@centos7: httpd-2.4.41]#apachectl start
[root@centos7: httpd-2.4.41]#apachectl stop
```



脚本 编译安装httpd 

```bash
#! /bin/bash

URL=https://downloads.apache.org//httpd/httpd-2.4.41.tar.bz2

TARDIR=`echo ${URL} | rev | cut -d"/" -f 1 | rev`

INSTALLDIR=/apps/httpd

echo URL=${URL}
echo TARDIR=${TARDIR}

""echo -e "\e[1;31m开始安装httpd\e[0m"
sleep 3

cd /usr/local/src
yum install gcc make wget apr-devel.x86_64 apr-util-devel.x86_64 -y
wget ${URL}
tar xf ${TARDIR} 
cd httpd*

./configure --prefix=${INSTALLDIR} --enable-ssl --enable-so
make && make install
echo `echo PATH=${INSTALLDIR}`/bin':$PATH' > /etc/httpd.sh
source /etc/httpd.sh

# 用户
useradd -r apache -s /sbin/nologin

sed -i "s/^User.*/User apache/g" ${INSTALLDIR}/conf/httpd.conf; 
sed -i "s/^Group.*/Group apache/g" ${INSTALLDIR}/conf/httpd.conf;

httpd -k restart

echo -e "\e[1;31mhttpd安装完成\e[0m"
```





## httpd安装与ubuntu软件包管理

httpd源码编译安装脚本：



### Ubuntu软件管理

Debian软件包通常为预编译的二进制格式的扩展名".deb",类似rpm文件,因此安装快速，无需编译软件。包文件包括特定功能或软件所必需的文件、元数据和指令

+ dpkg: package manager for Debian,类似于rpm，dpkg是基 于Debian的系统的包管理器。可以安装，删除和构建软件包，但无法自动下载和安装软件包或其依赖项
+ apt: Advanced Packaging Tool, 功能强大的软件管理工具，甚至可升级整个Ubunty的系统，基于客户/服务器架构

#### APT工作原理

在服务器上先复制所有DEB包，然后用APT的分析工具genbasedir根据每个DEB包的包头(Header) 信息对所有的DEB包进行分析，并将该分析结果记录在文件夹base内的一个DEB索引清单文件中，一旦APT服务器内的DEB有所变动，要使用genbasedir产生新的DEB索引清单。客户端在进行安装或升级时先要查询DEB索引清单，从而获知所有具有依赖关系的软件包，并一同下载到客户端以便安装。当客户端需要安装、升级或删除某个软件包时,客户端计算机取得DEB索引清单压缩文件后，会将其解压置放于/var/cache/apt/,而客户端使用apt-get install或apt-get upgrade命令的时候，就会将这个文件夹内的数据和客户端计算机内的DEB数据库比对，知道哪些DEB已安装、未安装或是可以升级的

#### dpkg 包管理器

帮助参考：man dpkg

dpkg常见用法

```bash
#安装包
dpkg -i package.deb

#删除包，不建议，不自动卸载卸载依赖于它的包
dpkg -r package

#删除包（包括配置文件）
dpkg -P package

#列出当前已安装的包，类似于rpm -qa
dpkg -l

#显示该包的简要说明，类似rpm -qi
dpkg -l package

#列出该包中包含的文件，类似于rpm -ql
dpkg -L package

#搜索包含pattern的包，类似于rpm -af
dpkg -S <pattern>

#列出该包的状态，包括详细信息，类似于rpm -ai
dpkg -s package

#配置包， -a 使用，配置所有没有配置的软件包
dpkg --configure package

#列出 deb 包的内容，类似rpm -qpl
dpkg -c package.deb

#解开 deb包的内容
dpkg --unpack package.deb
```

范例：

```bash
#列出系统上安装的所有软件包
dpkg -l

#列出软件包安装的文件
dpkg -L bash

#查看/bin/bash来自那个软件包
dpkg -S /bin/bash

#安装本地的 .deb 文件
dpkg -i /mnt/cdrom/pool/main/z/zip/zip_3.0011build1_amd64.deb

#卸载软件包
dpkg -r zip
```

注意：一般不建议使用dpkg卸载软件包。因为删除包时，其它依赖它的包不会卸载，并且可能无法正常运行。

#### apt

+ Debian使用apt工具集来管理包系统，apt-get 是其中一个常用的命令行工具，另外一款较为流行的命令行与GUI兼顾的工具是aptitude，之前最常用的Linux包管理命令都被分散在了apt-get、 apt-cache 和apt-config这三条命令中

+ 在2014年apt命令发布第一个稳定版，Ubuntu 16.04引入新特性之一便是apt命令, apt 命令解决了命令过于分散的问题，它包括apt-get命令出现以来使用最广泛的功能选项，以及apt-cache和apt-config命令中很少用到的功能。在使用apt命令时，用户不必再由apt-get转到apt-cache或apt-config，提供管理软件包所需的必要选项。
+ apt相当于apt-get、apt-cache 和apt-config中最常用命令选项的集合
+ apt具有更精减但足够的命令选项，而且参数选项的组织方式更为有效。此外，启用的几个特性也非常有帮助。例如:可以在使用apt令安装或删除程序时看到进度条,apt还会在更新存储库数据库时提示用户可升级的软件包

apt仓库路径：/etc/apt/sources.list

https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11A2JuXm

修改完仓库源后，更新下

```bash
apt update
```
apt与apt-get命令对比

| apt命令  | 被取代的命令 | 命令的功能 |
| :------- | :------------ | :------------ |
| apt install	 |     apt-get install  |安装软件包|
| apt remove	| apt-get remove |移除软件包|
| apt purge	| apt-get purge |移除软件包及配置文件|
| apt update	| apt-get update |刷新存储库索引|
| apt upgrade	| apt-get upgrade |升级所有可升级的软件包|
| apt autoremove	| apt-get autoremove |自动删除不需要的包|
| apt full-upgrade	| apt-get dist-upgrade |在升级软件包时自动处理依赖关系|
| apt searce	| apt-cache search |搜索应用程序|
| apt show	| apt-cache show |显示安装细节|



## 磁盘结构与分区方式MBR和GPT

```bash
for i in {0..32};do echo '- - -' > /sys/class/scsi_host/host$i/scan;done
```

### 磁盘存储和文件系统



#### 内容概述

+ 磁盘结构
+ 分区类型
+ 管理分区
+ 管理文件系统
+ 挂载设备
+ 管理swap空间
+ RAID管理
+ LVM管理和LVM快照



#### 1.磁盘结构：

##### 1.1设备文件

一切皆文件: open(). read(). write(). close()

设备文件:关联至一个设备驱动程序， 进而能够跟与之对应硬件设备进行通信

设备号码:

+ 主设备号: major number,标识设备类型

+ 次设备号: minor number,标识同一类型下的不同设备

设备类型:

+ 块设备: block, 存取单位“块"，磁盘

+ 字符设备: char, 存取单位”字符”，键盘

磁盘设备的设备文件命名:

```bash
/dev/DEV_ FILE
/dev/sdx #SCSI, SATA, SAS, IDE ,USB
```

虚拟磁盘:

```bash
/dev/vd
/dev/xvd
```

不同磁盘标识: a-z.aa,ab....

示例:

```
/dev/sda, /dev/sdb, ...
```

同一设备上的不同分区：1，2，...

```
/dev/sda1
/dev/sda5
```

##### 1.2硬盘类型

![1584703556332](..\typora-user-images\1584703556332.png)

硬盘接口类型：

+ IDE: 133MB/s

+ SCSI: 640MB/s
+ SATA: 6Gbps
+ SAS: 6Gbps,
+ USB: 480MB/S，
+ M.2

##### 1.3机械硬盘和固态硬盘

机械硬盘(HDD) : Hard Disk Drive,即是传统普通硬盘，主要由:盘片,磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成。机械硬盘中所有的盘片都装在一个旋转轴上， 每张盘片之间是平行的，在每个盘片的存储面上有一个磁头, 磁头与盘片之间的距离比头发丝的直径还小，所有的磁头联在一个磁头控制器上，由磁头控制器负责各个磁头的运动。磁头可沿盘片的半径方向运动，加上盘片每分钟几千转的高速旋转，磁头就可以定位在盘片的指定位置上进行数据的读写操作。数据通过磁头由电磁流来改变极性方式被电磁流写到磁盘上,也可以通过相反方式读取。硬盘为精密设备，进入硬盘的空气必须过滤

固态硬盘(SSD) : Solid State Drive,用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元(FLASH芯片、DRAM芯片)组成。固态硬盘在接口的规范和定义、功能及使用方法上与普通硬盘的完全相同，在产品外形和尺寸上也与普通硬盘一致

相较于HDD, SSD在防震抗摔、传输速率、功耗、重量、噪音上有明显优势，SSD传输速率性能是HDD的2倍。相较于SSD.，HDD在价格、容量占有绝对优势

硬盘有价，数据无价，目前SSD不能完全取代HHD



机械硬盘结构（HDD）

![1584704695254](..\typora-user-images\1584704695254.png)



固态硬盘（SSD）

![1584704800052](..\typora-user-images\1584704800052.png)



##### 1.4硬盘存储术语

![1584704856179](..\typora-user-images\1584704856179.png)



磁盘存储术语 CHS

+ head:磁头 磁头数=盘面数

+ track: 磁道 磁道数=柱面数

+ sector: 扇区，512bytes

+ cylinder: 柱面 1柱面=512bytes * sector数/track * head数=7.84M

  早期的Linux（CentOS 5）以往以柱面的整数倍划分分区，CentOS 6之后可以支持以扇区划分分区

  范例：

  ```
  [root@centOS7: ~]#echo "scale=2;512*63*255/1024/1024"|bc
  7.84
  
  ```

  

![1584704980328](..\typora-user-images\1584704980328.png)

​				

![1584705040697](..\typora-user-images\1584705040697.png)

CHS和LBA

+ CHS采用24bit位寻址
+ 其中前10位表示cylinder, 中间8位表示head,后面6位表示sector

+ 最大寻址空间8GB

LBA (logical block addressing)

+ LBA是一 个整数，通过转换成CHS格式完成磁盘具体寻址
+ ATA-1规范中定义了28位寻址模式，以每扇区512位组来计算，ATA-1所定义的28位LBA上限达到128 GiB。2002年ATA-6规范采用48位LBA，同样以每扇区512位组计算容量上限可达128 Petabytes

由于CHS寻址方式的寻址空间在大概8GB以内，所以在磁盘容最小于大概8GB时，可以使用CHS寻址方式或是LBA

寻址方式;在磁盘容量大于大概8GB时,则只能使用LBA寻址方式



#### 2 管理存储

使用磁盘空间过程

1.设备分区

2.创建文件系统

3.挂载新的文件系统

##### 2.1磁盘分区

**2.1.1为什么分区**

+ 优化I/0性能
+ 实现磁盘空间配额限制
+ 提高修复速度
+ 隔离系統和程序

+ 安装多个OS
+ 采用不同文件系統

**2.1.2分区方式**

两种分区方式: MBR,GPT

**2.1.2.1 MBR分区**

MBR: Master Boot Record, 1982年， 使用32位表示扇区数，分区不超过2T

划分分区的单位:

+ CentOS 5之前按整柱面分
+ CentOS 6版本后可以按sector分

0磁道0扇区: 512bytes

+ 446 bytes: boot loader
+ 64 bytes:分区表，其中每16bytes标识一个分区
+ 2 bytes: 55AA

MBR分区中一块硬盘最多有4个主分区，也可以3主分区+ 1扩展(N个逻辑分区)

MBR分区结构

![1584707841383](..\typora-user-images\1584707841383.png)

硬盘主引导记录MBR由4个部分组成

<table>
    <tr>
    	<td>0000-0088</td>
        <td>Master Boot Record 主引导程序</td>
        <td>主引导程序</td>
    </tr>
    <tr>
    	<td>0089-01BD</td>
        <td>出错信息数据区</td>
        <td>数据区</td>
    </tr>
    <tr>
    	<td>01BE-01CD</td>
        <td>分区项1（16字节）</td>
        <td rowspan="4">分区表</td>
    </tr>
    <tr>
    	<td>01CE-01DD</td>
        <td>分区项2（16字节）</td>
    </tr>
    <tr>
    	<td>01DE-01ED</td>
        <td>分区项3（16字节）</td>
    </tr>
    <tr>
    	<td>01EE-01FD</td>
        <td>分区项4（16字节）</td>
    </tr>
    <tr>
    	<td>01FE</td>
        <td>55</td>
        <td rowspan="2">结束标志</td>
    </tr>
    <tr>
    	<td>01FF</td>
        <td>AA</td>
    </tr>
</table>



+ 主引导程序(偏移地址000H--0088H)，它负责从活动分区中装载,并运行系统引导程序
+ 出错信息数据区，偏移地址0089H--00E1H为出错信息, 00E2H-01 BDH全为0字节
+ 分区表(DPT,Disk Partition Table) 含4个分区项,偏移地址01BEH-01FDH,每个分区表项长16个字节，共64字节为分区项1、分区项2、分区项3、分区项4
+ 结束标志字，偏移地址01FE--01FF的2个字节值为结束标志55AA

MBR中DPT结构

<table >
	 <tr>
    	<td style="width:200px;">存储字节位</td>
        <td style="width:400px;">内容及定义</td>
    </tr>
	<tr>
		<td>第一字节</td>
		<td>引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。</td>
	</tr>
	<tr>
		<td>第2、3、4字节</td>
        <td>本分区的起始磁头号、扇区号、柱面号。其中：<br>
		磁头号 - - 第2字节；<br>
		扇区号 - - 第3字节的低6位；<br>
		柱面号 - - 为第3字节高2位+第4字节8位。<br>
		</td>
	</tr>
	<tr>
		<td>第5字节</td>
		<td>分区类型符。<br>
			00H - - 表示该分区未用(即没有指定)，<br>
			06H - - FAT16基本分区;<br>
			OBH - - FAT32基本分区;<br>
			05H - - 扩展分区;<br>
			07H - - NTFS分区;<br>
			OFH - - (LBA模式)扩展分区( 83H为Linux分区等)。
		</td>
	</tr>
	<tr>
		<td>第6、7、8字节</td>
		<td>本分区的结束磁头号、扇区号、柱面号。其中:<br>
		磁头号 - - 第6字节:<br>
		扇区号 - - 第7字节的低6位:<br>
		柱面号 - - 第7字节的高2位+第8字节。
		</td>
	</tr>
	<tr>
		<td>第9、10、11、12字节</td>
		<td>本分区之前已用了的扇区数。</td>
	</tr>
	<tr>
		<td>第13、14、15、16字节</td>
		<td>本分区的总扇区数。</td>
	</tr>
    </table>



范例：备份MBR的分区表，并破坏恢复

```
[root@centos7: ~]#dd if=/dev/sda of=/data/dpt.img bs=1 count=64 skip=446
[root@centos7: ~]#scp /data/dpt.img 192.168.2.101:
[root@centos7: ~]#dd if=/dev/zero of=/dev/sda bs=1 count=64 seek=446

#无法启动
[root@centos7: ~]#reboot

#用光盘启动。进入rescure mode，选第3项skip to shell
#ifconfig ens160 192.168.2.100/24
#scp 192.168.2.101:/root/dpt.img .
#dd if=dpt.img of=/dev/sda bs=1 seek=446
#exit
```





**2.1.2.2 GPT分区**

GPT: GUID (Globals Unique Identifiers) partition table支持128个分区，使用64位, 支持8Z (512Byte/block) 64Z ( 4096Byte/block)

使用128位UUID(Universally Unique ldentifier)表示磁盘和分区GPT分区表自动备份在头和尾两份，并有CRC校验位

UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持GPT，使得操作系统可以启动

**GPT分区结构**

GPT分区结构分为4个区域:

+ GPT头
+ 分区表
+ GPT分区
+ 备份区域

**2.1.3 BIOS和UEFI **

BIOS是固化在电脑主板上的程序，主要用于开机系统自检和引导操作系统。目前新式的电脑基本上都是UEFI启动BIOS (Basic Input Output System基本输入输出系统)主要完成系统硬件自检和引导操作系统，操作系统开始启动之后，BIOS的任务就完成了。系统硬件自检:如果系统硬件有故障，主板上的扬声器就会发出长短不同的“滴滴音"，可以简单的判断硬件故障,比如”1长1短通常表示内存故障，“1长3短”通 常表示显卡故障

**BIOS**在1975年就诞生了，使用汇编语言编写，当初只有16位，因此只能访问1M的内存,其中前640K称为基本内存，后384K内存留给开机和各类BIOS本身使用。BIOS只能识别到主引导记录(MBR) 初始化的硬盘，最大支持2T的硬盘，4个主分区(逻辑分区中的扩展分区除外)，而目前普遍实现了64位系统，传统的BIOS已经无法满足需求了，这时英特尔主导的EFI就诞生了

**EFI** (Extensible Firmware Interface) 可扩展固件接口，是Intel为PC固件的体系结构、接口和服务提出的建议标准。其主要目的是为了提供一组在OS加载之前(启动前)在所有平台上一致的、正确指定的启动服务，被看做是BIOS的继任者

**UEFI**是由EFI1.10为基础发展起来的，它的所有者已不再是Intel,而是一个称作Unified EFI Form的国际组织UEF(Unified Extensible Firmware Interface)統一的可扩 展固件接口，是一种详细描述类型接口的标准。UEFI 相当于一个轻量化的操作系统，提供了硬件和操作系统之间的一个接口，提供了图形化的操作界面。最关键的是引入了GPT分区表，支持2T以上的硬盘,硬盘分区不受限制



**BIOS和UEFI区别**

BIOS采用了16位汇编语言编写，只能运行在实模式(内存寻址方式由16位段寄存器的内容乘以16(10H)当做段基地址，加上16位偏移地址形成20位的物理地址)下，可访问的内存空间为1MB，只支持字符操作界面

UEFI采用32位或者64位的C语言编写，突破了实模式的限制，可以达到最大的寻址空间，支持图形操作界面

**BIOS+MBR与UEFI+GPT**

![1584715290858](..\typora-user-images\1584715290858.png)





## 分区相关管理工具

**2.1.3 管理分区**

列出块设备

```bash
lsblk
```

创建分区命令

```
fdisk 管理MBR分区
gdisk 管理GPT分区
parted 高级分区操作
```

重新设置内存中得内核分区表版本

```
partprobe
```



**2.1.3.1 parted命令**

parted的操作都是实时生效的，小心使用

格式：

```bash
parted [option]... [设备[命令[参数]...]...]
```

范例：

```bash
parted /dev/sdb mklabel gpt|msdos
parted /dev/sdb print
parted /dev/sdb mkpart primary 1 200 (默认单位M)
parted /dev/sdb rm 1 (分区Number)
parted -l 列出所有硬盘分区信息
```

范例：

```bash
[root@centos7: ~]#lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   19G  0 part 
  ├─centos-root 253:0    0   17G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0   10G  0 disk 
sdc               8:32   0    5G  0 disk 
sr0              11:0    1  4.3G  0 rom  /run/media/centos7/CentOS 7 x86_64

[root@centos7: ~]#parted /dev/sdb print
Error: /dev/sdb: unrecognised disk label
Model: VMware, VMware Virtual S (scsi)                                    
Disk /dev/sdb: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: unknown
Disk Flags: 
[root@centos7: ~]#parted /dev/sdb mklabel gpt
Information: You may need to update /etc/fstab.
[root@centos7: ~]#parted /dev/sdb print                                   
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start  End  Size  File system  Name  Flags

[root@centos7: ~]#parted /dev/sdb mkpart primary 1 1001
Information: You may need to update /etc/fstab.

[root@centos7: ~]#parted /dev/sdb print                                   
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End     Size    File system  Name     Flags
 1      1049kB  1001MB  1000MB               primary

[root@centos7: ~]#parted /dev/sdb rm 1
Information: You may need to update /etc/fstab.

[root@centos7: ~]#parted /dev/sdb print                                   
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 10.7GB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start  End  Size  File system  Name  Flags


```



**2.1.3.2 分区工具fdisk和gdisk**

```bash
#管理GPT分区
gdisk /dev/sdb
# 查看分区
fdisk -l [-u][device...] 

#管理MGR分区
fdisk /dev/sdb

#子命令：
p	分区表
t	更改分区类型
n	创建新分区
d	删除分区
v	校验分区
u	转换单位
w	保存并退出
q	不保存退出

```

查看内核是否已经识别新的分区

```bash
cat /proc/partations
```

CentOS 6 通知内核重新读取硬盘分区表

新增分区用：

```bash
# 同步
partx -a /dev/DEVICE
kpartx -a /dev/DEVICE -f: force
```

删除分区用

```bash
# 同步(M,N是分区号)
partx -d --nr M-N /dev/DEVICE
```

CentOS 5,7,8 使用partprobe 同步分区表

```bash
partprobe [/dev/DEVICE]
```





