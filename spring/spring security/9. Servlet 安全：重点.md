# 9. Servlet 安全：重点

Spring Security 的 Servlet 支持是基于 Servlet 过滤器的。下面的图片显示了单个 HTTP 请求的处理程序的典型分层。

![filterchain](9. Servlet 安全：重点.assets/filterchain.png)

客户机向应用程序发送一个请求，容器会创建一个FilterChain（过滤器链），一个Servlet最多可以处理单个HttpServletRequest和HttpServletResponse，但是可以处理多个Filter。

+ 过滤下游Filters和Servlet
+ 修改下游Filters和Servlet的HttpServletRequest和HttpServletResponse对象

**使用范例**

```java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    // do something before the rest of the application
    chain.doFilter(request, response); // invoke the rest of the application
    // do something after the rest of the application
}
```

由于Filter指影响下游Filter和Servlet，因此每个过滤器被调用顺序非常重要。



## 9.1.DelegatingFilterProxy

Spring 提供了一个名为 DelegatingFilterProxy 的 Filter 实现，允许在 Servlet 容器的生命周期和 Spring 的 ApplicationContext 之间建立桥接。Servlet 容器允许使用自己的标准注册过滤器，但它不知道 Spring 定义的 Beans。可以通过标准的 Servlet 容器机制注册 DelegatingFilterProxy，但将所有工作委托给一个实现 Filter 的 Spring Bean。

下面是 DelegatingFilterProxy 如何适用于 Filters 和 FilterChain 的图片。

![delegatingfilterproxy](9. Servlet 安全：重点.assets/delegatingfilterproxy.png)



DelegatingFilterProxy 从 ApplicationContext 查找 Bean Filter0，然后调用 Bean Filter0。下面是 DelegatingFilterProxy 的伪代码。

**Pseudo Code**

```java
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    // Lazily get Filter that was registered as a Spring Bean
    // For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0
    Filter delegate = getFilterBean(someBeanName);
    // delegate work to the Spring Bean
    delegate.doFilter(request, response);
}
```

DelegatingFilterProxy 的另一个好处是，它允许延迟查看 Filter bean 实例。这很重要，因为容器需要在容器启动之前注册 Filter 实例。然而，Spring 通常使用一个 ContextLoaderListener 来加载 Spring Beans，这在 Filter 实例需要注册之前不会执行。

## 9.2.FilterChainProxy

Spring Security 的 Servlet 支持包含在 FilterChainProxy 中。FilterChainProxy 是 Spring Security 提供的一个特殊的 Filter，它允许通过 SecurityFilterChain 将代理委托给许多 Filter 实例。因为 FilterChainProxy 是一个 Bean，所以它通常包装在 DelegatingFilterProxy 中。



![filterchainproxy](9. Servlet 安全：重点.assets/filterchainproxy.png)



## 9.3.SecurityFilterChain

SecurityFilterChain使用FilterChainProxy来确定应该为本次请求调用哪个 Spring Security 过滤器。

![securityfilterchain](9. Servlet 安全：重点.assets/securityfilterchain.png)

SecurityFilterChain 中的Security Filters 通常是 Beans，但它们是通过 FilterChainProxy 而不是 DelegatingFilterProxy 注册的。FilterChainProxy 为直接在 Servlet 容器或 DelegatingFilterProxy 注册提供了许多优点。

+ 首先，它为 Spring Security 的所有 Servlet 支持提供了一个起点。出于这个原因，如果您尝试对 Spring Security 的 Servlet 支持进行故障排除，那么在 FilterChainProxy 中添加一个调试点是一个很好的起点。
+ 其次，因为 FilterChainProxy 是 Spring Security 使用的核心，它可以执行那些不能被视为可选的任务。例如，它清除 SecurityContext 以避免内存泄漏。它还应用 Spring Security 的 HttpFirewall 来保护应用程序免受某些类型的攻击。
+ 此外，它在确定何时调用 SecurityFilterChain 方面提供了更大的灵活性。在 Servlet 容器中，仅根据 URL 调用过滤器。但是，FilterChainProxy 可以利用 RequestMatcher 接口根据 HttpServletRequest 中的任何内容来确定调用。
+ 事实上，可以使用 FilterChainProxy 来确定应该使用哪个 SecurityFilterChain。如果您的应用程序需要，这允许为应用程序的不同部分提供完全独立的配置。

![multi securityfilterchain](9. Servlet 安全：重点.assets/multi-securityfilterchain.png)

**图：多重安全过滤链**

在 多重安全过滤链 图中，FilterChainProxy 决定应该使用哪个 SecurityFilterChain。只有第一个匹配的SecurityFilterChain将被调用。如果请求/api/messages/的 URL，它将首先匹配 securityfilterchain0的/api/\** 模式，因此只会调用 SecurityFilterChain0，即使它也匹配 SecurityFilterChainn。如果请求/messages/的 URL，它将不匹配 securityfilterchain0的/api/\** 模式，因此 FilterChainProxy 将继续尝试每个 SecurityFilterChain。假设没有其他的 SecurityFilterChain 实例匹配 SecurityFilterChainn 将被调用。

注意 securityfilterchain0只配置了三个安全过滤器实例。但是，SecurityFilterChainn 配置了四个安全过滤器。需要注意的是，每个 SecurityFilterChain 可以是唯一的，并且可以隔离配置。实际上，如果应用程序希望 Spring Security 忽略某些请求，SecurityFilterChain 可能具有零安全筛选器。



## 9.4.Security Filters

Security Filters 通过 SecurityFilterChain API 插入到 FilterChainProxy 中。Security Filters的顺序很重要。通常不需要知道 Spring Security 的过滤器的顺序。然而，有时候知道顺序是有益的。

下面是 Spring Security Filter 排序的综合列表:

1. ChannelProcessingFilter
2. ConcurrentSessionFilter
3. WebAsyncManagerIntegrationFilter
4. SecurityContextPersistenceFilter
5. HeaderWriterFilter
6. CorsFilter
7. CsrfFilter
8. LogoutFilter
9. OAuth2AuthorizationRequestRedirectFilter
10. Saml2WebSsoAuthenticationRequestFilter
11. X509AuthenticationFilter
12. AbstractPreAuthenticatedProcessingFilter
13. CasAuthenticationFilter
14. OAuth2LoginAuthenticationFilter
15. Saml2WebSsoAuthenticationFilter
16. [`UsernamePasswordAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/5.3.13.RELEASE/reference/html5/#servlet-authentication-usernamepasswordauthenticationfilter)
17. ConcurrentSessionFilter
18. OpenIDAuthenticationFilter
19. DefaultLoginPageGeneratingFilter
20. DefaultLogoutPageGeneratingFilter
21. [`DigestAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/5.3.13.RELEASE/reference/html5/#servlet-authentication-digest)
22. BearerTokenAuthenticationFilter
23. [`BasicAuthenticationFilter`](https://docs.spring.io/spring-security/site/docs/5.3.13.RELEASE/reference/html5/#servlet-authentication-basic)
24. RequestCacheAwareFilter
25. SecurityContextHolderAwareRequestFilter
26. JaasApiIntegrationFilter
27. RememberMeAuthenticationFilter
28. AnonymousAuthenticationFilter
29. OAuth2AuthorizationCodeGrantFilter
30. SessionManagementFilter
31. [`ExceptionTranslationFilter`](https://docs.spring.io/spring-security/site/docs/5.3.13.RELEASE/reference/html5/#servlet-exceptiontranslationfilter)
32. [`FilterSecurityInterceptor`](https://docs.spring.io/spring-security/site/docs/5.3.13.RELEASE/reference/html5/#servlet-authorization-filtersecurityinterceptor)
33. SwitchUserFilter



### 9.5.Handling Security Exceptions 处理安全异常

ExceptionTranslationFilter 允许将 AccessDeniedException 和 AuthenticationException 转换为 HTTP 响应。

ExceptionTranslationFilter 作为安全过滤器之一插入到 FilterChainProxy 中。

![exceptiontranslationfilter](9. Servlet 安全：重点.assets/exceptiontranslationfilter.png)



**流程如下：**

1. 首先，ExceptionTranslationFilter 调用 FilterChain.doFilter (request, response)来调用应用程序的其余部分。
2. 如果用户没有经过身份验证，或者它是 AuthenticationException，那么启动身份验证（Start Authentication）。
   1. Security contextholder 被清空了
   2. HttpServletRequest 保存在 RequestCache 中。当用户成功验证时，使用 RequestCache 重播原始请求。
   3. AuthenticationEntryPoint 用于从客户机请求凭据。例如，它可能会重定向到一个登录页面，或者发送一个 WWW-Authenticate 响应头
3. 否则，如果它是一个 AccessDeniedException，那么拒绝访问。

> 如果应用程序没有抛出 AccessDeniedException 或 AuthenticationException，那么 ExceptionTranslationFilter 不会执行任何操作。



**ExceptionTranslationFilter 伪代码如下：**

```java
try {
    filterChain.doFilter(request, response); //1
} catch (AccessDeniedException | AuthenticationException e) {
    if (!authenticated || e instanceof AuthenticationException) {
        startAuthentication(); //2
    } else {
        accessDenied(); //3
    }
}
```

1. 继续调用应用程序其余部分，如果程序其余部分（FilterSecurityInterceptor，或方法上鉴权）抛出了一个AuthenticationException或者AccessDeniedException，那么会在这里进行捕获处理。
2. 如果用户没有经过身份验证，或者身份验证失败（AuthenticationException），那么将会启动认证（Start Authectication）
3. 否则，拒绝访问。