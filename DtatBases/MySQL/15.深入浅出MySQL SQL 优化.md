# 15 SQL 优化

​		在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。



## 15.1 优化 SQL 语句的一般步骤  

​		当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题 。

​		本章大部分涉及的案例表位于MySQL 案例库 Sakila 上。

​		压缩包包括三个文件：sakila-schema.sql 、 sakila-data.sql 和 sakila.mwb ，分别是 Sakila库的表结构创建、数据灌入、Sakila的MySQL Workbench 数据模型（可以在MySQL 工作台打开查看数据库模型）

> Sakila 是一个MySQL 官方提供的模拟电影出租厅信息管理系统的数据库，可以在 https://dev.mysql.com/doc/index-other.html 下载。



### 15.1.1 通过 show status 命令了解各种 SQL 的执行频率  

​		MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”  

​		下面的命令显示了当前 session 中所有统计参数的值：  

```mysql
mysql> show status like 'Com_%';
+-------------------------------------+-------+
| Variable_name                       | Value |
+-------------------------------------+-------+
| Com_admin_commands                  | 0     |
| Com_assign_to_keycache              | 0     |
| Com_alter_db                        | 0     |
| Com_alter_event                     | 0     |
| Com_alter_function                  | 0     |
| Com_alter_instance                  | 0     |
| Com_alter_procedure                 | 0     |
| Com_alter_resource_group            | 0     |
| Com_alter_server                    | 0     |
| Com_alter_table                     | 0     |
| Com_alter_tablespace                | 0     |
...
| Compression                         | OFF   |
+-------------------------------------+-------+
168 rows in set (0.00 sec)
```

​		Com_xxx 表示每个xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

+ Com_select：执行 SELECT 操作的次数，一次查询只累加1.
+ Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT操作，只累加一次。
+ Com_update：执行UPDATE操作的次数
+ Com_delete：执行DELETE操作的次数

​		上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。

+ Innodb_rows_read：SELECT查询返回的行数
+ Innodb_rows_inserted：执行INSERT 操作插入的行数。
+ Innodb_rows_updated：执行UPDATE操作更新的行数。
+ Innodb_rows_deleted：执行DELETE 操作删除的行数。

​		通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。

​		对于事务型的应用通过Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。

+ Connections：视图链接MySQL服务器的次数。
+ Uptime：服务器工作时间。
+ Slow_queries：慢查询的次数。



### 15.1.2 定位执行效率较低的 SQL 语句 

​		可以通过以下两种方式定位执行效率较低的 SQL 语句。

1. 通过慢查询日志定位那些执行效率较低的 SQL 语句，将 slow-query-log 参数设置为1之后，MySQL 会将所有执行时间超过 long_query_time 参数所设定阈值的 SQL，写入slow_query_log_file 参数所指定的文件中。
2. 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。  



### 15.1.3 通过 EXPLAIN 分析低效 SQL 的执行计划  

​		通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想统计某个 email 为租赁电影拷贝所支付的总金额，需要关联客户表 customer 和 付款表 payment，并且对付款金额 amount 字段做求和（sum）操作，相应SQL的执行计划如下：

```mysql
mysql> explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 10.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.a.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

​		对每个列简单地进行一下说明。

+ select_type：表示 SELECT 的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。
+ table：输出结果集的表。
+ possible_keys：表示查询时可能是用的索引。
+ key：表示实际使用的索引。
+ key_len：使用到索引字段的长度。
+ rows：扫描行的数量。
+ Extra：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息。
+ filtered：返回结果的行占需要读到的行(rows列的值)的百分比。
+ type：表示MySQL在表中找到所需行的方式，或者叫访问类型，常见的类型有（从上到下，性能由最差到最好）。
  + ALL
  + index
  + range
  + ref
  + eq_ref
  + const,system
  + NULL

（1）type=ALL,全表扫描，MySQL 遍历全表来找到匹配的行：

```mysql
mysql> explain select * from film where rating > 9 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

（2）type=index，索引全扫描，MySQL遍历整个索引来查询匹配的行：

```mysql
mysql> explain select title from film\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_title
      key_len: 514
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

（3）type=range，索引范围扫描，常见于 <,<=,>,>=,between 等操作。

```mysql
mysql> explain select * from payment where customer_id >=300 and customer_id <=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: NULL
         rows: 1350
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（4）type=ref，使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值得记录行，例如：

```mysql
mysql> explain select * from payment where customer_id=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 23
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

​		索引 idx_fk_customer_id 是非唯一索引，查询条件为等值查询条件 customer_id=350,所以扫描索引的类型为ref。ref还经常出现在join操作中：

```mysql
mysql> explain select b.*,a.* from payment a, customer b where a.customer_id=b.customer_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.b.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

（5）type=eq_ref，类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配；简单来说，就是多表连接中使用 primary key 或者 unique index 作为关联条件。

```mysql
mysql> explain select * from film a, film_text b where a.film_id=b.film_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.b.film_id
         rows: 1
     filtered: 100.00
        Extra: Using where
2 rows in set, 1 warning (0.00 sec)
```

> 为什么a是eq_ref,b是all？
>
> 个人理解是因为，a表是使用了主键字段（film_id）去关联b表的主键字段（film_id），所以a表的type=eq_ref, 虽然b表字段 film_id 也是主键，但是需要全表扫描去匹配。

（6）type=const/system，表单中最多有一个匹配行，查询起来非常迅速，所以这个匹配行中的其它列的值可以被优化器在当前查询中当作常量来处理，例如，根据主键 primary key 或者唯一索引 unique index 进行的查询。

​		构造一个查询：

```mysql
mysql> alter table customer add unique index uk_email(email);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from (select * from customer where email='AARON.SELBY@sakilacustomer.org') a \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: const
possible_keys: uk_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

> 注意，教材上还有一条数据，type是system。这里使用的mysql 8.0.16 只有一个const

通过唯一索引 uk_email 访问的时候，类型 type为 const。

（7）type=NULL，MySQL不用访问表或者索引，直接就能够得到结果，例如：

```mysql
mysql> explain select 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)
```

​		类型type 还有其它的值，比如 ref_or_null（与ref类似，区别在于条件中包含对NULL的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询）等。



​		MySQL从5.1版本开始支持分区功能，同时 explain 命令也增加了对分区的支持。可以通过explain partitions 命令查看SQL 所访问的分区。例如创建一个Hash分区的 customer_part 表，根据分区键查询的时候，能够看到 explain partitions 的输出结果中有一列 partitions，其中 显示了 SQL 所需要访问的分区名字 p2：

> 数据暂不支持分区，需要安装mysql 并开启分区。

​		有时，仅仅通过 explain 分析执行计划并不能很快地定位 SQL 地问题，那么这时我们还可以选择 profile 联合分析。



### 15.1.4 通过 show profile 分析SQL

​		MySQL 从 5.0.37 版本开始增加了对 show profiles 和 show profile 语句地支持。通过have_profiling 参数，能够看到当前MySQL 是否支持 profile:

```mysql
mysql> select @@have_profiling;
+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+
1 row in set, 1 warning (0.00 sec)
```

​		默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：

```mysql
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.00 sec)
mysql> set profiling=1;
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

​		通过 profile，用户能够更清楚地了解SQL 执行地过程。例如，我们都知道 MyISAM 表有表元数据地缓存（例如行数，即COUNT（\*）值），那么对一个MyISAM 表地 COUNT(\*) 是不需要消耗太多资源地，而对于 InnoDB 来说，就没有这种元数据缓存，COUNT(\*) 就执行的较慢。下面做个实验来验证下。

​		首先，在一个 innodb 引擎地付款表 payment 上，执行一个 COUNT(\*) 查询：

```mysql
mysql> select count(*) from payment;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.03 sec)
```

​		执行完毕后，通过 show profiles 语句，看到当前 SQL 的 Query ID 为 6：

```mysql
mysql> show profiles;
+----------+------------+------------------------------+
| Query_ID | Duration   | Query                        |
+----------+------------+------------------------------+
|        1 | 0.00021950 | select @@profiling           |
|        2 | 0.00698925 | show databases               |
|        3 | 0.00023800 | SELECT DATABASE()            |
|        4 | 0.00642000 | show tables                  |
|        5 | 0.00963100 | show create table payment    |
|        6 | 0.03248600 | select count(*) from payment |
+----------+------------+------------------------------+
6 rows in set, 1 warning (0.00 sec)
```

​		通过 `show profile for query` 语句能够看到执行过程中线程的每个状态和消耗的时间：

```mysql
mysql> show profile for query 6;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000119 |
| Executing hook on transaction  | 0.000004 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000264 |
| init                           | 0.000011 |
| System lock                    | 0.000010 |
| optimizing                     | 0.000005 |
| statistics                     | 0.000016 |
| preparing                      | 0.000030 |
| executing                      | 0.000002 |
| Sending data                   | 0.031881 |
| end                            | 0.000012 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000018 |
| closing tables                 | 0.000009 |
| freeing items                  | 0.000081 |
| cleaning up                    | 0.000013 |
+--------------------------------+----------+
18 rows in set, 1 warning (0.00 sec)
```

> 注意：Sending data 状态表示MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅是返回结果给客户端。由于在 Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。

​		通过仔细检查 `show profile for query` 的输出，能够发现在执行 COUNT(\*) 的过程中，时间主要消耗在 Sending data 这个状态上。为了更清晰地看到排序结果，可以查询 INFORMATION_SCHEMA.PROFILING 表 并按照时间做个 DESC 排序。

```mysql
mysql> set @query_id :=6;
Query OK, 0 rows affected (0.00 sec)

mysql> select 
			state, sum(duration) as total_r, 
			round(100 * sum(duration) / (
        		select sum(duration) from information_schema.profiling where query_id=@query_id
    		), 2) as Pct_R, 
    		count(*) as calls, 
    		sum(duration) / count(*) as 'R/Call' 
    from INFORMATION_SCHEMA.profiling 
    where query_id=@query_id group by state order by total_r desc;
+--------------------------------+----------+-------+-------+--------------+
| state                          | total_r  | Pct_R | calls | R/Call       |
+--------------------------------+----------+-------+-------+--------------+
| Sending data                   | 0.031881 | 98.13 |     1 | 0.0318810000 |
| Opening tables                 | 0.000264 |  0.81 |     1 | 0.0002640000 |
| starting                       | 0.000125 |  0.38 |     2 | 0.0000625000 |
| freeing items                  | 0.000081 |  0.25 |     1 | 0.0000810000 |
| preparing                      | 0.000030 |  0.09 |     1 | 0.0000300000 |
| waiting for handler commit     | 0.000018 |  0.06 |     1 | 0.0000180000 |
| statistics                     | 0.000016 |  0.05 |     1 | 0.0000160000 |
| cleaning up                    | 0.000013 |  0.04 |     1 | 0.0000130000 |
| end                            | 0.000012 |  0.04 |     1 | 0.0000120000 |
| init                           | 0.000011 |  0.03 |     1 | 0.0000110000 |
| System lock                    | 0.000010 |  0.03 |     1 | 0.0000100000 |
| closing tables                 | 0.000009 |  0.03 |     1 | 0.0000090000 |
| optimizing                     | 0.000005 |  0.02 |     1 | 0.0000050000 |
| Executing hook on transaction  | 0.000004 |  0.01 |     1 | 0.0000040000 |
| checking permissions           | 0.000004 |  0.01 |     1 | 0.0000040000 |
| query end                      | 0.000004 |  0.01 |     1 | 0.0000040000 |
| executing                      | 0.000002 |  0.01 |     1 | 0.0000020000 |
+--------------------------------+----------+-------+-------+--------------+
17 rows in set, 18 warnings (0.01 sec)
```

​		在获取到最消耗时间的线程状态后，MySQL 支持进一步选择 all、cpu、block io、context switch、page faults 等明细类型来查看MySQL在使用什么资源上耗费了过高的时间，例如，选择查看CPU 的耗费时间：

```mysql
mysql> show profile cpu for query 6;
+--------------------------------+----------+----------+------------+
| Status                         | Duration | CPU_user | CPU_system |
+--------------------------------+----------+----------+------------+
| starting                       | 0.000119 | 0.000000 |   0.000000 |
| Executing hook on transaction  | 0.000004 | 0.000000 |   0.000000 |
| starting                       | 0.000006 | 0.000000 |   0.000000 |
| checking permissions           | 0.000004 | 0.000000 |   0.000000 |
| Opening tables                 | 0.000264 | 0.000000 |   0.000000 |
| init                           | 0.000011 | 0.000000 |   0.000000 |
| System lock                    | 0.000010 | 0.000000 |   0.000000 |
| optimizing                     | 0.000005 | 0.000000 |   0.000000 |
| statistics                     | 0.000016 | 0.000000 |   0.000000 |
| preparing                      | 0.000030 | 0.000000 |   0.000000 |
| executing                      | 0.000002 | 0.000000 |   0.000000 |
| Sending data                   | 0.031881 | 0.031250 |   0.015625 |
| end                            | 0.000012 | 0.000000 |   0.000000 |
| query end                      | 0.000004 | 0.000000 |   0.000000 |
| waiting for handler commit     | 0.000018 | 0.000000 |   0.000000 |
| closing tables                 | 0.000009 | 0.000000 |   0.000000 |
| freeing items                  | 0.000081 | 0.000000 |   0.000000 |
| cleaning up                    | 0.000013 | 0.000000 |   0.000000 |
+--------------------------------+----------+----------+------------+
18 rows in set, 1 warning (0.00 sec)
```

​		能够发现 Sending data 状态下，时间主要消耗在 CPU上了。

​		对比MyISAM 表的 COUNT(\*) 操作，也创建了一个同样表结构的 MyISAM 表，数据量也完全一致：

```mysql
mysql> create table payment_myisam like payment;
Query OK, 0 rows affected (0.04 sec)

mysql> alter table payment_myisam engine=myisam;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> insert into payment_myisam select * from payment;
Query OK, 16049 rows affected (0.16 sec)
Records: 16049  Duplicates: 0  Warnings: 0
```

​		同样执行 count(\*) 操作，检查 profile :

```mysql
mysql> select count(*) from payment_myisam;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.00 sec)


mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec)

mysql> show profiles \G;
....
*************************** 14. row ***************************
Query_ID: 23
Duration: 0.00027050
   Query: select count(*) from payment_myisam
15 rows in set, 1 warning (0.00 sec)   
 
 
mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec) 
```

​		从 profile 的结果能够看出，InnoDB 引擎的表在 count(\*) 时经历了 Sending data 状态，存在访问数据的过程，而 myisam 引擎的表在 executing 之后直接就结束查询，完全不需要访问数据。

​		show profile 能够在做 SQL 优化时帮助我们了解事件都耗费在哪里去了。而MySQL 5.6 之后则通过 trace 文件进一步向我们展示了优化器是如何执行计划的。

> 注意：在MySQL5.7中，profile 已经不建议使用，而使用 performance schema中的一系列性能视图来替代。



### 15.1.5 通过 trace 分析优化器如何选择执行计划

​		MySQL 从5.6 版本开始提供了对sql的跟踪 trace，通过 trace 文件能够进一步了解为什么优化器选择 A 执行计划而不选择 B执行计划，帮助我们更更好的理解优化器行为。

​		使用方式：首先打开 trace，设置格式为 JSON，设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整显示。

```mysql
mysql> set optimizer_trace='enabled=on', end_markers_in_json=on;
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_trace_max_mem_size=1000000;
Query OK, 0 rows affected (0.00 sec)
```

​		接下来执行想做trace 的sql 语句，例如，想了解租赁表 rental 中库存编号 inventory_id 为 4466 的电影拷贝在出租日期 rental_date 为 2005-05-25 4:00:00 ~5:00:00 出租的记录：

```mysql
mysql> select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466;
+-----------+
| rental_id |
+-----------+
|        39 |
+-----------+
1 row in set (0.02 sec)
```

​		然后检查 INFORMATION_SCHEMA.OPTIMIZER_TRACE 就可以知道 MySQL是如何执行sql语句的：

​		最后会输出一个格式如下的跟踪文件：

```mysql
mysql> select * from information_schema.optimizer_trace\G;
*************************** 1. row ***************************
                            QUERY: select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466
                            TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `rental`.`rental_id` AS `rental_id` from `rental` where ((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "((`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": {
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`rental`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
              {
                "table": "`rental`",
                "field": "inventory_id",
                "equals": "4466",
                "null_rejecting": false
              }
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`rental`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 16008,
                    "cost": 1699.9
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "rental_date",
                      "usable": true,
                      "key_parts": [
                        "rental_date",
                        "inventory_id",
                        "customer_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_inventory_id",
                      "usable": true,
                      "key_parts": [
                        "inventory_id",
                        "rental_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_customer_id",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_fk_staff_id",
                      "usable": false,
                      "cause": "not_applicable"
                    }
                  ] /* potential_range_indexes */,
                  "best_covering_index_scan": {
                    "index": "rental_date",
                    "cost": 1629.1,
                    "chosen": true
                  } /* best_covering_index_scan */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "rental_date",
                        "usable": false,
                        "cause": "prefix_not_const_equality"
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "rental_date",
                        "ranges": [
                          "0x9975b24000 <= rental_date <= 0x9975b25000"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false,
                        "using_mrr": false,
                        "index_only": true,
                        "rows": 10,
                        "cost": 2.0254,
                        "chosen": true
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "ranges": [
                          "4466 <= inventory_id <= 4466"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 5,
                        "cost": 6.51,
                        "chosen": false,
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "rental_date",
                      "rows": 10,
                      "ranges": [
                        "0x9975b24000 <= rental_date <= 0x9975b25000"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 10,
                    "cost_for_plan": 2.0254,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`rental`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "access_type": "ref",
                      "index": "idx_fk_inventory_id",
                      "rows": 5,
                      "cost": 5.5,
                      "chosen": true
                    },
                    {
                      "rows_to_scan": 10,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "rental_date"
                      } /* range_details */,
                      "resulting_rows": 10,
                      "cost": 3.0254,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 10,
                "cost_for_plan": 3.0254,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`rental`",
                  "attached": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`rental`",
                "original_table_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
                "final_table_condition   ": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
              }
            ] /* finalizing_table_conditions */
          },
          {
            "refine_plan": [
              {
                "table": "`rental`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0
          INSUFFICIENT_PRIVILEGES: 0
1 row in set (0.01 sec)
```

​		文件里面记录很多信息，包括访问表的路径、行数、成本等，来帮助读者对执行计划的选择过程进行分析。



### 15.1.6 确定文体并采取相应的优化措施

​		经过上面的步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措施，进行优化以提高执行的效率。

​		上面某个例子可以确认是由于对客户表 customer 的全表扫描导致效率不理想，那么对客户表 customer 的 email 字段创建索引，具体如下：

```mysql
mysql> create index idx_email on customer(email);
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		创建索引后，再看下这条语句的执行计划，具体如下：

```mysql
mysql>  explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: const
possible_keys: PRIMARY,uk_email,idx_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 28
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.01 sec)
```

​		可以发现，建立索引后对客户表 customer 需要扫描的行数明显减少（从599 行减少到1 行）。可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候，这种优势更为明显。



## 15.2 索引问题

​		索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的SQL性能问题。本节将详细讨论MySQL 中索引的分类、存储和使用方法。

### 15.2.1 索引的存储分类

​		索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MySQL目前提供了以下4种索引。

1. B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。
2. HASH索引：只有 Memory/NDB 引擎支持，使用场景简单。
3. R-Tree 索引（空间索引）：空间索引是MyISAM 的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍
4. Full-text（全文索引）：全文索引也是MyISAM 的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL 5.6 版本开始提供对全文索引的支持。

MySQL 目前版本（8.0.11）还不支持函数索引（8.0.13 开始已经支持），但是可以通过两种方式实现函数索引的功能。

（1）前缀索引，即对列的前面某一部分进行索引。例如标题 title 字段，可以只取 title 的前 10 个字符进行索引，这个特性可以大大缩小索引文件的大小，但前缀索引也有缺点，在排序 order by 和 分组 操作的时候无法使用。用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。

​		下面是创建前缀索引的一个例子：

```mysql
mysql> create index idx_title_1 on film(title(10)) ;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

（2）虚拟列索引。在Oracle 等大多商业数据库种，早已支持函数索引，但MySQL一直没有实现这个功能。在MySQL5.7之后，可以通过创建虚拟列索引的方式来实现函数索引的功能，如下例所示：

​		创建表sql

```mysql
mysql> create table salaries  (emp_no int(11),salary int(11),from_date date, to_date date, primary key (emp_no,from_date));
Query OK, 0 rows affected (0.05 sec)
```



​		在表 salaries 中执行如下 sql

```mysql
mysql> select * from salaries where round(salary/1000) < 10;
```

​		表地定义如下：

```mysql
mysql> desc salaries;
+-----------+---------+------+-----+---------+-------+
| Field     | Type    | Null | Key | Default | Extra |
+-----------+---------+------+-----+---------+-------+
| emp_no    | int(11) | NO   | PRI | NULL    |       |
| salary    | int(11) | YES  |     | NULL    |       |
| from_date | date    | NO   | PRI | NULL    |       |
| to_date   | date    | YES  |     | NULL    |       |
+-----------+---------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

​		此时，直接在 salary 上创建 索引并不会被这个 sql 使用。这里创建一个虚拟列 salary_by_lk：

```mysql
mysql> alter table salaries add column salary_by_lk int generated always as (round(salary/1000));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		然后在这个虚拟列上创建索引：

```mysql
mysql> alter table salaries add key odx_salary_by_lk(salary_by_lk);
Query OK, 0 rows affected (0.03 sec)
```

​		此时观察执行计划，显示新创建的虚拟列索引已经被使用：

```mysql
mysql> desc select count(1) from salaries where round(salary/1000)<10 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: salaries
   partitions: NULL
         type: range
possible_keys: odx_salary_by_lk
          key: odx_salary_by_lk
      key_len: 5
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

```

​		实际执行后，SQL 的执行时间从 8s 降到了 0.2 s。



下面比较MyISAM、InnoDB、Memory 这三个常用引擎支持的索引类型。

| 索引           | MyISAM 引擎 | InnoDB 索引 | Memory 索引 |
| -------------- | ----------- | ----------- | ----------- |
| B-Tree 索引    | 支持        | 支持        | 支持        |
| HASH 索引      | 不支持      | 不支持      | 支持        |
| R-Tree 索引    | 支持        | 不支持      | 不支持      |
| Full-text 索引 | 支持        | 支持        | 不支持      |

​		比较常用到的索引就是 B-Tree 索引和 Hash索引。Hash索引相对简单，只有 Memory/NDB 引擎支持完全的Hash索引，InnoDB 存储引擎在MySQL 5.7 中支持自适应的 Hash索引。所谓自适应，就是MySQL 根据数据的访问频率和模式为某些热点页自动创建Hash索引，索引由 buffer pool 中的B-Tree 来自动生成，效率很高，这个特性由参数 innodb_adaptive_hash_index来控制，默认是打开的。

​		Hash索引适用于 Key-Value 查询，通过Hash索引要比通过B-Tree索引查询更迅速；Hash索引不适用范围查询，例如 <.><=,>= 这类操作。如果使用 Memory/NDB 引擎并且 where 条件不使用 ”=“ 进行索引列，那么就不会用到索引。Memory/Heap 引擎只有在 ”=“ 的条件下才会使用索引。

​		B-Tree 索引比较复杂，下面将详细分析MySQL是如何利用 B-Tree 索引的。



### 15.2.2 MySQL 如何使用索引

​		B-Tree 索引是最常见的索引，构造类似二叉树，能根据键值提供一行或者一个行集的快速访问，通常只需要很少的读操作就可以找到正确的行。不过，需要注意B-Tree索引中的B不代表二叉树（binary），而是代表平衡树（balanced）。B-Tree并不是一颗二叉树。

​		为了避免混淆，重命名租赁表 rental 上的索引 rental_date 为 idx_rental_date:

```mysql
mysql> alter table rental rename index rental_date to idx_rental_date;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

1. MySQL中能够使用索引的典型场景

   （1）匹配全值（Mathch the full value），对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。例如，租赁表 rental 中通过指定出租日期 rental_date + 库存编号 inventory_id + 客户编号 customer_id 的组合条件 进行查询，从执行计划的 key 和 extra 两个字段的值看到优化器选择了复合索引 idx_rental_date:

   ```mysql
   mysql> explain select * from rental where rental_date='2005-05-25 17:22:10' and inventory_id=373 and customer_id=343 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: const
   possible_keys: idx_rental_date,idx_fk_inventory_id,idx_fk_customer_id
             key: idx_rental_date
         key_len: 10
             ref: const,const,const
            rows: 1
        filtered: 100.00
           Extra: NULL
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		explain 输出结果中字段type的值为const，表示是常量；字段key的值为idx_rental_date,表示优化器选择索引idx_rental_date 进行扫描。

   （2）匹配值的范围查询（Mathch a range of values）,对索引的值能够进行范围查找。例如，检索租赁表 rental中客户编号 customer_id 在指定范围内的记录：

   ```mysql
   mysql> explain select * from rental where customer_id > 373 and customer_id <400 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: range
   possible_keys: idx_fk_customer_id
             key: idx_fk_customer_id
         key_len: 2
             ref: NULL
            rows: 683
        filtered: 100.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		l类型 type 为range 说明优化器选择范围查询，索引 key 为 idx_fx-customer_id 说明优化器选择索引idx_fx_customer_id 来加速访问，注意到这个例子中Extra 列为 Using where，表示优化器除了用索引来加速访问之外，还需要根据索引回表查询数据。

   （3）匹配最左前缀（Match a leftmost prefix），仅仅使用索引中的最左边列进行查找，比如在 col1+col2+col3 字段上的联合索引能够被包含col1、（col1+col2）、（col1+col2+col3） 的等值查询利用到，可是不能够被 col2、（col2+col3）的等值查询利用到；以支付表 payment 为例，如果查询条件中仅包含索引的第一列支付日期 payment_date 和 索引 的第三列更新时间 last_update 的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_last_update的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_date 进行条件过滤：

   ````mysql
   mysql> alter table payment add index idx_payment_date (payment_date, amount, last_update);
   Query OK, 0 rows affected (0.14 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   
   mysql> explain select * from payment where payment_date='2006-02-14 15:16:03' and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 5
             ref: const
            rows: 182
        filtered: 10.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ````

   ​		但是，如果仅仅选择复合索引 idx_payment_date 的第二列支付金额amount和 第三列更新时间 last_update_date 进行查询时，那么执行计划显示并不会利用到索引 idx_payment_date:

   ```mysql
   mysql> explain select * from payment where amount = 3.98 and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 1.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		最左匹配原则可以算是 MySQL中B-Tree 索引使用首要原则。

   （4）仅仅对索引进行查询（Index only query），当查询的列都在索引的字段中时，查询的效率更高；对比上一个例子使用 select *, 本次选择查询的字段都包含在索引 idx_payment_date 中时，能够看到查询计划有一点变动：

   ```mysql
   mysql> explain select  last_update from payment where payment_date='2006-02-14 15:16:03' and amount = 3.98 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 8
             ref: const,const
            rows: 8
        filtered: 100.00
           Extra: Using index
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		Extra 部分变成了 Using index ，也就意味着，现在直接访问索引就足够获取到所需要的数据，不需要通过索引回表，Using index 也就是平时说的覆盖索引扫描。只访问必须访问的数据，在一般情况下，减少不必要的数据访问能够提升效率。

（5）匹配列前缀（match a column prefix）,仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。例如，现在需要查询出标题 title 是以 AFRICAN 开头的电影信息，从执行计划能够清楚看到， idx_title_desc_part 索引被利用上了：

```mysql
mysql> create index idx_title_desc_part on film_text (title(10), description(20));
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select title from film_text where title like 'AFRICAN%'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_text
   partitions: NULL
         type: range
possible_keys: idx_title_desc_part,idx_title_description
          key: idx_title_desc_part
      key_len: 42
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		Extra 值为 Using where 表示优化器需要通过索引回表查询数据。

（6）能够实现索引匹配部分精确而其他部分进行范围匹配（match one part exactly and match a range on another part）。例如，需要查询出租日期 rental_date 为指定日期且客户编号 customer_id 为指定范围的库存：

```mysql
mysql> explain select inventory_id from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using where; Using index
1 row in set, 1 warning (0.01 sec)
```

​		类型type 为 range 说明优化器选择范围查询，索引 key 为 idx_rental_date 说明优化器选择索引 idx_rental_date 帮助加速查询，同时由于子=只查询索引字段 inventory_id 的值，所以在extra 部分能看到 using index ，表示查询使用了覆盖索引扫描。

（7）如果列名是索引，那么使用 column_name is null 就会使用索引（区别于 Oracle）。例如，查询支付表 payment 的租赁编号 rental_id 字段为空的记录就用到了索引：

```mysql
mysql> explain select * from payment where rental_id is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: fk_payment_rental
          key: fk_payment_rental
      key_len: 5
          ref: const
         rows: 5
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（8）MySQL5.6引入了 Index Condition Pushdown (ICP) 的特性，进一步优化了查询。Pushdown 表示操作下放，某些情况下的条件过滤操作下放到存储引擎。

​		例如，查询租赁表rental 中租赁时间 rental_date 在某一指定时间点且客户编号 customer_id 在指定范围内的数据，MySQL5.5/5.1的执行计划显示：优化器首先使用复合索引 idx_rental_date 的首字段 rental_date 过滤出符合条件 rental_date='2006-02-14 15:16:03' 的记录（执行计划中的key 字段值显示为 idx_rental_date），然后根据复合索引 idx_rental_date 回表获取记录后，最终根据条件 customer_id >= 300 and customer_id <= 400 来过滤出最后的查询结果（执行计划中 Extra 字段值显示为 Using where）。

```mysql
mysql> select version();
+-----------+
| version() |
+-----------+
| 8.0.16    |
+-----------+
1 row in set (0.00 sec)

mysql> explain select * from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

​		MySQL5.7 上做同样的案例，能够发现 Explain 执行计划 的Extra 部分从using where 变成了 Using index condition 的提示

​		Using index condition 表示MySQL使用了ICP 来进一步优化查询，在检索的时候，把条件 customer_id 的过滤操作下推到存储引擎层来完成，这样能够降低不必要的IO访问。



2. 存在索引但不能使用索引的典型场景

   ​	有些时候虽然有索引，但是不被优化器选择使用。下面列举几个不能使用索引的常见场景。

   （1）以 % 开头的 LIKE 查询不能利用 B-Tree 索引，执行计划中key 的值为NULL 表示没有用到索引。

   ```mysql
   mysql> explain select * from actor where last_name like '%NI%'\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 200
        filtered: 11.11
           Extra: Using where
   1 row in set, 1 warning (0.04 sec)
   ```

   ​		因为 B-Tree 索引的结构，所以以 % 开头的查询很自然就没法利用索引了，一般都推荐使用全文索引（Filltext）来解决类似的全文检索问题。或者考虑利用InnoDB的表都是聚簇表的特点，采取一种轻量级别的解决方式：一般情况下，索引都会比表小，扫描索引要比扫描表更快（某些特殊的情况下，索引比表更大），而 InnoDB表上二级索引 idx_last_name 实际上存储字段 last_name 还有主键 actor_id，那么理想的访问方式应该是首先扫描二级索引 idx_last_name 获得满足条件 last_name like '%NI%' 的主键 actor_id 列表，之后根据主键回表去检索记录，这样访问避开了全表扫描演员表 actor 产生的大量IO 请求。验证一下：

   ```mysql
   mysql> explain select * from (select actor_id from actor where last_name like '%NI%')a,actor b where a.actor_id=b.actor_id\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: index
   possible_keys: PRIMARY
             key: idx_actor_last_name
         key_len: 182
             ref: NULL
            rows: 200
        filtered: 11.11
           Extra: Using where; Using index
   *************************** 2. row ***************************
              id: 1
     select_type: SIMPLE
           table: b
      partitions: NULL
            type: eq_ref
   possible_keys: PRIMARY
             key: PRIMARY
         key_len: 2
             ref: sakila.actor.actor_id
            rows: 1
        filtered: 100.00
           Extra: NULL
   2 rows in set, 1 warning (0.00 sec)
   ```

   ​		从执行计划可以看到，内层查询的Using index 代表索引覆盖扫描，之后通过主键 join 操作去演员表actor 中获取最终查询结果，理论上是能够比直接全表扫描更快一些。

   （2）数据类型出现隐式转换的时候也不会使用索引，特别是当列类型是字符串时，那么一定记得在 where 条件中把字符常量值用引号引起来，否则即便这个列上有索引，MySQL 也不会用到，因为MySQL默认把输入的常量值进行转换以后才进行检索。例如，演员表actor 中的姓氏字段 last_name 是字符型的，但是SQL 语句中的条件值 1 是 一个数值类型，因此即便存在索引 idx_last_name,MySQL也不能正确地用上索引，而是继续全表扫描：

   ```mysql
   mysql> explain select * from actor where last_name=1 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ALL
   possible_keys: idx_actor_last_name
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 200
        filtered: 10.00
           Extra: Using where
   1 row in set, 3 warnings (0.00 sec)
   ```

   ​		加上引号之后，再次检查执行计划，就发现使用上索引了：

   ```mysql
   mysql> explain select * from actor where last_name='1' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ref
   possible_keys: idx_actor_last_name
             key: idx_actor_last_name
         key_len: 182
             ref: const
            rows: 1
        filtered: 100.00
           Extra: NULL
   1 row in set, 1 warning (0.00 sec)
   ```

   （3）复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 Leftmost， 是不会使用复合索引的：

   ```mysql
   mysql> explain select * from payment where amount= 3.98 and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 1.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   （4）如果MySQL估计使用索引比全表扫面更慢，则不使用索引。例如，查询以“S” 开头的电影标题，需要返回的记录比较大，MySQL就预估索引扫描还不如全表扫描更快：

   ```mysql
   mysql> update film_text set title=concat('S', title);
   Query OK, 1000 rows affected (0.17 sec)
   Rows matched: 1000  Changed: 1000  Warnings: 0
   
   mysql> explain select * from film_text where title like 'S%' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: film_text
      partitions: NULL
            type: ALL
   possible_keys: idx_title_desc_part,idx_title_description
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 1000
        filtered: 100.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		在MySQL5.7 版本中，能够通过 Trace清晰地看到优化器选择地过程，全表扫描 table scan需要访问的纪录 rows 为 1000，代价cost 计算为233.53：

   ​		而对应 idx_title_desc_part 索引过滤条件时，优化器预估需要返回 998 条记录，访问代价 cost 为 1198.6,远高于全表扫描地代价，索引优化器倾向于选择全表扫面

   ​		更换查询地值为一个选择率更高的值，就能发现优化器更倾向于选择索引扫描：

   ```mysql
   mysql> explain select * from film_text where title like 'Sw%'\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: film_text
      partitions: NULL
            type: range
   possible_keys: idx_title_desc_part,idx_title_description
             key: idx_title_desc_part
         key_len: 42
             ref: NULL
            rows: 43
        filtered: 100.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		同样通过trace 能够看到，title like ‘Sw%’ 优化器预估需要返回66条记录，远小于全表扫面，所以优化器倾向于选择索引扫描。

   ​		也就是在查询时，筛选性越高越容易使用索引，筛选性越低越不容易使用索引。

   （5）用 or 分割开的条件，如果 or 前的条件中有索引，而后面的列中没有索引，那么涉及的索引都不会被用到，例如：

   ```mysql
   mysql> explain select * from payment where customer_id = 203 or amount = 3.96\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: idx_fk_customer_id
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 10.15
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		因为 or 后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加I/O访问，一次全表扫描过滤条件就足够了。

   

   ### 15.2.3 查看索引使用情况

   ​		如果索引正在工作，Handler_read_key 的值就会很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。

   ​		Handler_read_rnd_next 的值高意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正在进行大量的表扫描，Handler_read_rnd_next 的值较高，则通常说明表索引不正确，或写入的查询没有利用索引，具体如下：

   ```mysql
   mysql> show status like 'Handler_read%';
   +-----------------------+-------+
   | Variable_name         | Value |
   +-----------------------+-------+
   | Handler_read_first    | 1     |
   | Handler_read_key      | 69    |
   | Handler_read_last     | 0     |
   | Handler_read_next     | 50    |
   | Handler_read_prev     | 0     |
   | Handler_read_rnd      | 0     |
   | Handler_read_rnd_next | 1001  |
   +-----------------------+-------+
   7 rows in set (0.01 sec)
   ```

   

   ## 15.3 两个简单实用的优化方法

   ### 15.3.1 定期分析表和检查表

   ​		分析表的语法如下：

   ```mysql
   ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
   ```

   ​		本语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL 能够生成正确得执行计划。如果用户感觉实际执行计划并不是预期得执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM、BDB和InnoDB表有作用。对于MyISAM表，本语句与使用 myisamchk -a相当，下例中对表 sales 做了表分析：

   ```mysql
   mysql> analyze table payment;
   +----------------+---------+----------+----------+
   | Table          | Op      | Msg_type | Msg_text |
   +----------------+---------+----------+----------+
   | sakila.payment | analyze | status   | OK       |
   +----------------+---------+----------+----------+
   1 row in set (0.04 sec)
   ```

   ​		检查表得语法如下：

   ```mysql
   CHECK TABLE tbl_name [, tbl_name] ... [option] ... option={QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
   ```

   ​		检查表的作用是检查一个或多个表是否有错误。CHECK TABLE 对 MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新，例如：

   ```mysql
   mysql> check table payment_myisam;
   +-----------------------+-------+----------+----------+
   | Table                 | Op    | Msg_type | Msg_text |
   +-----------------------+-------+----------+----------+
   | sakila.payment_myisam | check | status   | OK       |
   +-----------------------+-------+----------+----------+
   1 row in set (0.02 sec)
   ```

   

   ​	CHECK TABLE 也可以检查试图是否有错误，比如在视图定义中被引用得表已不存在，下面给出一个示例。

   （1）首先创建一个视图：

   ```mysql
   mysql> create view v_payment_myisam as select * from payment_myisam;
   Query OK, 0 rows affected (0.02 sec)
   ```

   （2）然后 CHECk 一下该视图，发现没有问题：

   ```mysql
   mysql> check table v_payment_myisam;
   +-------------------------+-------+----------+----------+
   | Table                   | Op    | Msg_type | Msg_text |
   +-------------------------+-------+----------+----------+
   | sakila.v_payment_myisam | check | status   | OK       |
   +-------------------------+-------+----------+----------+
   1 row in set (0.01 sec)
   ```

   （3）现在删除掉视图依赖的表：

   ```mysql
   mysql> drop table payment_myisam;
   Query OK, 0 rows affected (0.03 sec)
   ```

   （4）再来CHECK 一下刚才的视图，发现报错了，并且提示出错的原因是 Table sakila.payent_myisam 不存在了：

   ```mysql
   mysql> check table v_payment_myisam \G;
   *************************** 1. row ***************************
      Table: sakila.v_payment_myisam
         Op: check
   Msg_type: Error
   Msg_text: View 'sakila.v_payment_myisam' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
   *************************** 2. row ***************************
      Table: sakila.v_payment_myisam
         Op: check
   Msg_type: error
   Msg_text: Corrupt
   2 rows in set (0.00 sec)
   ```




### 15.3.2 定期优化表

​		优化表的语法如下：

```mysql
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
```

​		如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表（含有 VARCHAR 、BLOB 或 TEXT 列的表）进行了很多更改，则应使用 OPTIMIZE TABLE 命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对 MyISAM、BDB 和 InnoDB 表起作用。命令执行期间 MyISAM 表会全程锁表，而InnoDB 表则会将优化命令转换为重建表和分析表两个操作，加锁时间也仅仅在整个工作的prepare 和 commit 期间做短暂的加锁工作，对于表的读写几乎没有影响。

​		以下例子显示了优化表 payment_myisam 的过程：

```mysql
mysql> optimize table payment_myisam;
+-----------------------+----------+----------+-----------------------------+
| Table                 | Op       | Msg_type | Msg_text                    |
+-----------------------+----------+----------+-----------------------------+
| sakila.payment_myisam | optimize | status   | Table is already up to date |
+-----------------------+----------+----------+-----------------------------+
1 row in set (0.00 sec)
```

​		对于InnoDB 引擎的表来说，通过设置 innodb_file_per_table 参数，设置InnoDB 为独立表空间模式，这样每个数据库的每个表都会生成一个独立的 ibd文件，用于存储表的数据和索引，这样可以一定程度上减轻InnoDB 表的空间回收问题。另外，在删除大量数据后，InnoDB 表可以通过alter table 但是不修改引擎的方式来回收不用的空间：

```mysql
mysql> alter table payment engine=innodb;
Query OK, 0 rows affected (0.93 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

> 注意：AMALYZE、CHECK、OPTIMIZE、ALTER TABLE 执行期间将对表进行锁定，因此一定注意要在数据库不繁忙的时候执行相关操作。



## 15.4 常用SQL的优化

​		前面已经介绍了MySQL中是如何通过索引来优化查询的。在日常开发中，除了使用查询外，我们还会使用一些其他的常用sql，比如 insert、group by等。下面将对于这些 sql语句介绍一些优化的方法。

### 15.4.1 大批量插入数据

​		当用 load命令导入数据的时候，适当的设置可以提高导入的速度。

​		对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。

```mysql
ALTER TABLE tbl_name DISABLE KEYS;
loading the data
ALTER TABLE tbl_name ENABLE KEYS;
```

​		DISABLE KEYS 和 ENABLE KEYS 用来打开或者关闭 MyISAM 表唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。

> load data 用法 https://www.cnblogs.com/yyy-blog/p/11073855.html



使用InnoDB类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。

（1）因为InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。

（2）在导入数据前执行 SET UNIQUE_CHECKS=0,关闭唯一性校验；在导入结束后执行 SET UNIQUE_CHECKS=1, 恢复唯一性校验，可以提高导入的效率。

（3）如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。

### 15.4.2 优化INSERT 语句

​		当进行数据 insert 的时候，可以考虑采用以下几种优化方式：

+ 如果同时从同一客户插入多行时:

  ```mysql
  insert into test values (1,2),(1,3)...
  ```

+ 如果从不同客户插入多行时，可以使用 INSERT DELAYED 语句得到更高的速度。DELAYED的含义是让 INSERT 语句马上执行，其实数据都被放在内存队列中，并没有真正写入磁盘，这比每条语句分别插入要快很多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完成后才进行插入。

+ 将索引文件和数据文件分别放在不同的磁盘上存放（利用建表中的选项）。

+ 如果进行批量插入，可以通过增加变量值  bulk_insert_buffer_size 的方法来提高速度，但是这种方式在只能对MyISAM表使用。

+ 当冲一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍。



### 15.4.3 优化 ORDER BY 语句

​		优化 order by 语句之前，首先来了解一下MySQL中的排序方式。先看 customer表上的索引情况：

```mysql
mysql> show index from customer \G
*************************** 1. row ***************************
        Table: customer
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: customer_id
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 2. row ***************************
        Table: customer
   Non_unique: 0
     Key_name: uk_email
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 3. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_fk_store_id
 Seq_in_index: 1
  Column_name: store_id
    Collation: A
  Cardinality: 2
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 4. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_fk_address_id
 Seq_in_index: 1
  Column_name: address_id
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 5. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_last_name
 Seq_in_index: 1
  Column_name: last_name
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 6. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_email
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
6 rows in set (0.04 sec)
```

#### 1. MySQL中有两种排序方式

​		第一种通过有序索引顺序扫描直接返回有序数据，这种方式在使用 explain 分析查询的时候显示为 Using Index，不需要额外的排序，操作效率较高，例如：

```mysql
mysql> explain select customer_id from customer order by store_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_fk_store_id
      key_len: 1
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

​		第二种是通过对返回数据进行排序，也就是通常说的 Filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 Filesort 排序。Filesort 并不代表通过磁盘文件进行排序，而只是说明进行了一个排序操作，至于排序操作是否使用了磁盘文件或临时表等，则取决于 mysql 服务器对排序参数的设置和需要排序数据的大小。例如，按照商店 store_id 排序返回所有客户记录时，出现了对全表扫描的结果的排序：

```mysql
mysql> explain select * from customer order by store_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		又如，只需要获取商店store_id 和顾客 email 信息时，对表 customer 的扫描就被对覆盖索引 idx_storeid_email 扫描替代，此时虽然只访问了索引就足够，但是在索引 idx_storeid_email 上发生了一次排序操作，所以执行计划中仍然有 Filesort。

```mysql
mysql> alter table customer add index idx_storeid_email(store_id, email);
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select store_id,email, customer_id from customer order by email \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_storeid_email
      key_len: 204
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using index; Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		Filesort 是通过相应的排序算法，将取得的数据在 sort_buffer_size 系统变量设置的内存排序区中进行排序，如果内存装载不下，它就会将磁盘上的数据进行分块，再对各个数据块进行排序，让后将各个快合并成有序的结果集。sort_buffer_size 设置的排序区是每个线程独占的，所以同一时刻，MySQL中存在多个 sort buffer 排序区。

​		了解了 MySQL排序的方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和 order by 使用相同的索引，并且order by 的顺序和索引顺序相同，并且 order by 的字段都是升序或者降序，否则肯定需要额外的排序操作，这样就会出现 Filesort。

​		例如查询商店编号 store_id 为1 ，按照 email 逆序排序的记录 主键 customer_id 时，优化器使用扫描索引 idx_storeid_email 直接返回 排序完毕的记录：

```mysql
mysql> explain select store_id, email, customer_id from customer where store_id=1 order by email desc \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: ref
possible_keys: idx_fk_store_id,idx_storeid_email
          key: idx_storeid_email
      key_len: 1
          ref: const
         rows: 326
     filtered: 100.00
        Extra: Backward index scan; Using index
1 row in set, 1 warning (0.00 sec)
```

​		而查询商店编号 store_id 大于等于 1 小于等于 3 ，按照email排序的记录主键customer_id 的时候，由于优化器评估使用 索引 idx_storeid_email 进行范围扫描代价 cost 最低，所以最终对索引扫描的结果，进行了额外的按照 ename 逆序排序操作：

```mysql
mysql> explain select store_id,email, customer_id from customer where store_id >=1 and store_id <=3 order by email desc \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: idx_fk_store_id,idx_storeid_email
          key: idx_storeid_email
      key_len: 204
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using where; Using index; Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		总结，下列sql可以直接使用索引：

```mysql
select * from tabname order by key_part1,key_part2,...;
select * from tabname where key_part1=1 order by key_part1 desc,key_part2 desc;
select * from tabname order by key_part1 desc, key_part2 desc;
```

​		但是以下几种情况下则不使用索引：

```mysql
# order by 的字段混合 asc 和 desc
select * from tabname order by key_part1 desc,key_part2 asc;
# 用于查询的关键字与order by 中使用的不相同
select * from tabname where key2=constant order by key1;
# 对不同关键字使用 order by
select * from tabname order by key1,key2;
```

#### 2. Filesort 优化

​		通过创建合适的索引能够减少 Filesort 出现，但是在某些情况下，条件限制不能让 Filesort 消失，那就需要想办法加快 Filesort 的操作。对于 Filesort ，MySQL有两种排序算法。

1. 两次扫描算法（Two Passes）：首先根据条件取出排序字段和行指针信息，之后在排序区 sort buffer 中排序，如果排序区 sort buffer 不够，则在临时表 Tempporary Table 中存储排序结果。完成排序后根据行指针回表读取记录。该算法是 MySQL4.1 之前采用的算法，需要两次访问数据，第一次获取排序字段和行指针信息，第二次根据行指针获取记录，尤其是第二次读取操作可能导致大量随机I/O操作；优点排序的时候内存开销较少。

2. 一次扫描算法（Single Pass）：一次性取出满足条件的行的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集，排序的时候内存开销比较大，但是排序效率比两次扫描要高。

   ​	

​        MySQL通过比较系统变量max_length_for_sort_data 的大小和 Query 语句取出的字段总大小来判断使用那种排序算法。如果max_length_for_sort_data更大，那么使用第二种优化之后的算法，否则使用第一种算法。

​        适当加大系统变量 max_length_for_sort_data 的值，能够让 MySQL 选择更优化的 Filesort 排序算法。当然，假如max_length_for_sort_data 设置过大，会造成CPU利用率过低和磁盘I/O过高，CUP 和 I/O平衡就足够了。

​		适当加大 sort_buffer_size 排序区，尽量让排序在内存中完成，而不是通过创建临时表存放在文件中进行；当然也不能无限制加大 sort_buffer_size 排序区，因为sort_buffer_size 参数是每个线程独占的，设置过大，会导致服务器 swap 严重，要考虑数据库活动链接数和服务器内存的大小适当设置。

​		尽量只使用必要的字段，select 具体的字段名称，而不是 select * 选择所有字段，这样可以减少排序区的使用，提高性能。



