# SQL 优化

​		在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。



## 优化 SQL 语句的一般步骤  

​		当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题 。

​		本章大部分涉及的案例表位于MySQL 案例库 Sakila 上。

​		压缩包包括三个文件：sakila-schema.sql 、 sakila-data.sql 和 sakila.mwb ，分别是 Sakila库的表结构创建、数据灌入、Sakila的MySQL Workbench 数据模型（可以在MySQL 工作台打开查看数据库模型）

> Sakila 是一个MySQL 官方提供的模拟电影出租厅信息管理系统的数据库，可以在 https://dev.mysql.com/doc/index-other.html 下载。



### 通过 show status 命令了解各种 SQL 的执行频率  

​		MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”  

​		下面的命令显示了当前 session 中所有统计参数的值：  

```mysql
mysql> show status like 'Com_%';
+-------------------------------------+-------+
| Variable_name                       | Value |
+-------------------------------------+-------+
| Com_admin_commands                  | 0     |
| Com_assign_to_keycache              | 0     |
| Com_alter_db                        | 0     |
| Com_alter_event                     | 0     |
| Com_alter_function                  | 0     |
| Com_alter_instance                  | 0     |
| Com_alter_procedure                 | 0     |
| Com_alter_resource_group            | 0     |
| Com_alter_server                    | 0     |
| Com_alter_table                     | 0     |
| Com_alter_tablespace                | 0     |
...
| Compression                         | OFF   |
+-------------------------------------+-------+
168 rows in set (0.00 sec)
```

​		Com_xxx 表示每个xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

+ Com_select：执行 SELECT 操作的次数，一次查询只累加1.
+ Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT操作，只累加一次。
+ Com_update：执行UPDATE操作的次数
+ Com_delete：执行DELETE操作的次数

​		上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。

+ Innodb_rows_read：SELECT查询返回的行数
+ Innodb_rows_inserted：执行INSERT 操作插入的行数。
+ Innodb_rows_updated：执行UPDATE操作更新的行数。
+ Innodb_rows_deleted：执行DELETE 操作删除的行数。

​		通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。

​		对于事务型的应用通过Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。

+ Connections：视图链接MySQL服务器的次数。
+ Uptime：服务器工作时间。
+ Slow_queries：慢查询的次数。



### 定位执行效率较低的 SQL 语句 

​		可以通过以下两种方式定位执行效率较低的 SQL 语句。

1. 通过慢查询日志定位那些执行效率较低的 SQL 语句，将 slow-query-log 参数设置为1之后，MySQL 会将所有执行时间超过 long_query_time 参数所设定阈值的 SQL，写入slow_query_log_file 参数所指定的文件中。
2. 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。  



### 通过 EXPLAIN 分析低效 SQL 的执行计划  

​		通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想统计某个 email 为租赁电影拷贝所支付的总金额，需要关联客户表 customer 和 付款表 payment，并且对付款金额 amount 字段做求和（sum）操作，相应SQL的执行计划如下：

```mysql
mysql> explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 10.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.a.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

​		对每个列简单地进行一下说明。

+ select_type：表示 SELECT 的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。
+ table：输出结果集的表。
+ possible_keys：表示查询时可能是用的索引。
+ key：表示实际使用的索引。
+ key_len：使用到索引字段的长度。
+ rows：扫描行的数量。
+ Extra：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息。
+ filtered：返回结果的行占需要读到的行(rows列的值)的百分比。
+ type：表示MySQL在表中找到所需行的方式，或者叫访问类型，常见的类型有（从上到下，性能由最差到最好）。
  + ALL
  + index
  + range
  + ref
  + eq_ref
  + const,system
  + NULL

（1）type=ALL,全表扫描，MySQL 遍历全表来找到匹配的行：

```mysql
mysql> explain select * from film where rating > 9 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

（2）type=index，索引全扫描，MySQL遍历整个索引来查询匹配的行：

```mysql
mysql> explain select title from film\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_title
      key_len: 514
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

（3）type=range，索引范围扫描，常见于 <,<=,>,>=,between 等操作。

```mysql
mysql> explain select * from payment where customer_id >=300 and customer_id <=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: NULL
         rows: 1350
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（4）type=ref，使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值得记录行，例如：

```mysql
mysql> explain select * from payment where customer_id=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 23
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

​		索引 idx_fk_customer_id 是非唯一索引，查询条件为等值查询条件 customer_id=350,所以扫描索引的类型为ref。ref还经常出现在join操作中：

```mysql
mysql> explain select b.*,a.* from payment a, customer b where a.customer_id=b.customer_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.b.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

（5）type=eq_ref，类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配；简单来说，就是多表连接中使用 primary key 或者 unique index 作为关联条件。

```mysql
mysql> explain select * from film a, film_text b where a.film_id=b.film_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.b.film_id
         rows: 1
     filtered: 100.00
        Extra: Using where
2 rows in set, 1 warning (0.00 sec)
```

> 为什么a是eq_ref,b是all？
>
> 个人理解是因为，a表是使用了主键字段（film_id）去关联b表的主键字段（film_id），所以a表的type=eq_ref, 虽然b表字段 film_id 也是主键，但是需要全表扫描去匹配。

（6）type=const/system，表单中最多有一个匹配行，查询起来非常迅速，所以这个匹配行中的其它列的值可以被优化器在当前查询中当作常量来处理，例如，根据主键 primary key 或者唯一索引 unique index 进行的查询。

​		构造一个查询：

```mysql
mysql> alter table customer add unique index uk_email(email);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from (select * from customer where email='AARON.SELBY@sakilacustomer.org') a \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: const
possible_keys: uk_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

> 注意，教材上还有一条数据，type是system。这里使用的mysql 8.0.16 只有一个const

通过唯一索引 uk_email 访问的时候，类型 type为 const。

（7）type=NULL，MySQL不用访问表或者索引，直接就能够得到结果，例如：

```mysql
mysql> explain select 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)
```

​		类型type 还有其它的值，比如 ref_or_null（与ref类似，区别在于条件中包含对NULL的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询）等。



​		MySQL从5.1版本开始支持分区功能，同时 explain 命令也增加了对分区的支持。可以通过explain partitions 命令查看SQL 所访问的分区。例如创建一个Hash分区的 customer_part 表，根据分区键查询的时候，能够看到 explain partitions 的输出结果中有一列 partitions，其中 显示了 SQL 所需要访问的分区名字 p2：

> 数据暂不支持分区，需要安装mysql 并开启分区。

​		有时，仅仅通过 explain 分析执行计划并不能很快地定位 SQL 地问题，那么这时我们还可以选择 profile 联合分析。