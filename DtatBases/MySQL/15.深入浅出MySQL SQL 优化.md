# 15 SQL 优化

​		在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。



## 15.1 优化 SQL 语句的一般步骤  

​		当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题 。

​		本章大部分涉及的案例表位于MySQL 案例库 Sakila 上。

​		压缩包包括三个文件：sakila-schema.sql 、 sakila-data.sql 和 sakila.mwb ，分别是 Sakila库的表结构创建、数据灌入、Sakila的MySQL Workbench 数据模型（可以在MySQL 工作台打开查看数据库模型）

> Sakila 是一个MySQL 官方提供的模拟电影出租厅信息管理系统的数据库，可以在 https://dev.mysql.com/doc/index-other.html 下载。



### 15.1.1 通过 show status 命令了解各种 SQL 的执行频率  

​		MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”  

​		下面的命令显示了当前 session 中所有统计参数的值：  

```mysql
mysql> show status like 'Com_%';
+-------------------------------------+-------+
| Variable_name                       | Value |
+-------------------------------------+-------+
| Com_admin_commands                  | 0     |
| Com_assign_to_keycache              | 0     |
| Com_alter_db                        | 0     |
| Com_alter_event                     | 0     |
| Com_alter_function                  | 0     |
| Com_alter_instance                  | 0     |
| Com_alter_procedure                 | 0     |
| Com_alter_resource_group            | 0     |
| Com_alter_server                    | 0     |
| Com_alter_table                     | 0     |
| Com_alter_tablespace                | 0     |
...
| Compression                         | OFF   |
+-------------------------------------+-------+
168 rows in set (0.00 sec)
```

​		Com_xxx 表示每个xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

+ Com_select：执行 SELECT 操作的次数，一次查询只累加1.
+ Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT操作，只累加一次。
+ Com_update：执行UPDATE操作的次数
+ Com_delete：执行DELETE操作的次数

​		上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。

+ Innodb_rows_read：SELECT查询返回的行数
+ Innodb_rows_inserted：执行INSERT 操作插入的行数。
+ Innodb_rows_updated：执行UPDATE操作更新的行数。
+ Innodb_rows_deleted：执行DELETE 操作删除的行数。

​		通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。

​		对于事务型的应用通过Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。

+ Connections：视图链接MySQL服务器的次数。
+ Uptime：服务器工作时间。
+ Slow_queries：慢查询的次数。



### 15.1.2 定位执行效率较低的 SQL 语句 

​		可以通过以下两种方式定位执行效率较低的 SQL 语句。

1. 通过慢查询日志定位那些执行效率较低的 SQL 语句，将 slow-query-log 参数设置为1之后，MySQL 会将所有执行时间超过 long_query_time 参数所设定阈值的 SQL，写入slow_query_log_file 参数所指定的文件中。
2. 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。  



### 15.1.3 通过 EXPLAIN 分析低效 SQL 的执行计划  

​		通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想统计某个 email 为租赁电影拷贝所支付的总金额，需要关联客户表 customer 和 付款表 payment，并且对付款金额 amount 字段做求和（sum）操作，相应SQL的执行计划如下：

```mysql
mysql> explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 10.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.a.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

​		对每个列简单地进行一下说明。

+ select_type：表示 SELECT 的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。
+ table：输出结果集的表。
+ possible_keys：表示查询时可能是用的索引。
+ key：表示实际使用的索引。
+ key_len：使用到索引字段的长度。
+ rows：扫描行的数量。
+ Extra：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息。
+ filtered：返回结果的行占需要读到的行(rows列的值)的百分比。
+ type：表示MySQL在表中找到所需行的方式，或者叫访问类型，常见的类型有（从上到下，性能由最差到最好）。
  + ALL
  + index
  + range
  + ref
  + eq_ref
  + const,system
  + NULL

（1）type=ALL,全表扫描，MySQL 遍历全表来找到匹配的行：

```mysql
mysql> explain select * from film where rating > 9 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

（2）type=index，索引全扫描，MySQL遍历整个索引来查询匹配的行：

```mysql
mysql> explain select title from film\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_title
      key_len: 514
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

（3）type=range，索引范围扫描，常见于 <,<=,>,>=,between 等操作。

```mysql
mysql> explain select * from payment where customer_id >=300 and customer_id <=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: NULL
         rows: 1350
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（4）type=ref，使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值得记录行，例如：

```mysql
mysql> explain select * from payment where customer_id=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 23
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

​		索引 idx_fk_customer_id 是非唯一索引，查询条件为等值查询条件 customer_id=350,所以扫描索引的类型为ref。ref还经常出现在join操作中：

```mysql
mysql> explain select b.*,a.* from payment a, customer b where a.customer_id=b.customer_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.b.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

（5）type=eq_ref，类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配；简单来说，就是多表连接中使用 primary key 或者 unique index 作为关联条件。

```mysql
mysql> explain select * from film a, film_text b where a.film_id=b.film_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.b.film_id
         rows: 1
     filtered: 100.00
        Extra: Using where
2 rows in set, 1 warning (0.00 sec)
```

> 为什么a是eq_ref,b是all？
>
> 个人理解是因为，a表是使用了主键字段（film_id）去关联b表的主键字段（film_id），所以a表的type=eq_ref, 虽然b表字段 film_id 也是主键，但是需要全表扫描去匹配。

（6）type=const/system，表单中最多有一个匹配行，查询起来非常迅速，所以这个匹配行中的其它列的值可以被优化器在当前查询中当作常量来处理，例如，根据主键 primary key 或者唯一索引 unique index 进行的查询。

​		构造一个查询：

```mysql
mysql> alter table customer add unique index uk_email(email);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from (select * from customer where email='AARON.SELBY@sakilacustomer.org') a \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: const
possible_keys: uk_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

> 注意，教材上还有一条数据，type是system。这里使用的mysql 8.0.16 只有一个const

通过唯一索引 uk_email 访问的时候，类型 type为 const。

（7）type=NULL，MySQL不用访问表或者索引，直接就能够得到结果，例如：

```mysql
mysql> explain select 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)
```

​		类型type 还有其它的值，比如 ref_or_null（与ref类似，区别在于条件中包含对NULL的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询）等。



​		MySQL从5.1版本开始支持分区功能，同时 explain 命令也增加了对分区的支持。可以通过explain partitions 命令查看SQL 所访问的分区。例如创建一个Hash分区的 customer_part 表，根据分区键查询的时候，能够看到 explain partitions 的输出结果中有一列 partitions，其中 显示了 SQL 所需要访问的分区名字 p2：

> 数据暂不支持分区，需要安装mysql 并开启分区。

​		有时，仅仅通过 explain 分析执行计划并不能很快地定位 SQL 地问题，那么这时我们还可以选择 profile 联合分析。



### 15.1.4 通过 show profile 分析SQL

​		MySQL 从 5.0.37 版本开始增加了对 show profiles 和 show profile 语句地支持。通过have_profiling 参数，能够看到当前MySQL 是否支持 profile:

```mysql
mysql> select @@have_profiling;
+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+
1 row in set, 1 warning (0.00 sec)
```

​		默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：

```mysql
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.00 sec)
mysql> set profiling=1;
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

​		通过 profile，用户能够更清楚地了解SQL 执行地过程。例如，我们都知道 MyISAM 表有表元数据地缓存（例如行数，即COUNT（\*）值），那么对一个MyISAM 表地 COUNT(\*) 是不需要消耗太多资源地，而对于 InnoDB 来说，就没有这种元数据缓存，COUNT(\*) 就执行的较慢。下面做个实验来验证下。

​		首先，在一个 innodb 引擎地付款表 payment 上，执行一个 COUNT(\*) 查询：

```mysql
mysql> select count(*) from payment;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.03 sec)
```

​		执行完毕后，通过 show profiles 语句，看到当前 SQL 的 Query ID 为 6：

```mysql
mysql> show profiles;
+----------+------------+------------------------------+
| Query_ID | Duration   | Query                        |
+----------+------------+------------------------------+
|        1 | 0.00021950 | select @@profiling           |
|        2 | 0.00698925 | show databases               |
|        3 | 0.00023800 | SELECT DATABASE()            |
|        4 | 0.00642000 | show tables                  |
|        5 | 0.00963100 | show create table payment    |
|        6 | 0.03248600 | select count(*) from payment |
+----------+------------+------------------------------+
6 rows in set, 1 warning (0.00 sec)
```

​		通过 `show profile for query` 语句能够看到执行过程中线程的每个状态和消耗的时间：

```mysql
mysql> show profile for query 6;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000119 |
| Executing hook on transaction  | 0.000004 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000264 |
| init                           | 0.000011 |
| System lock                    | 0.000010 |
| optimizing                     | 0.000005 |
| statistics                     | 0.000016 |
| preparing                      | 0.000030 |
| executing                      | 0.000002 |
| Sending data                   | 0.031881 |
| end                            | 0.000012 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000018 |
| closing tables                 | 0.000009 |
| freeing items                  | 0.000081 |
| cleaning up                    | 0.000013 |
+--------------------------------+----------+
18 rows in set, 1 warning (0.00 sec)
```

> 注意：Sending data 状态表示MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅是返回结果给客户端。由于在 Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。

​		通过仔细检查 `show profile for query` 的输出，能够发现在执行 COUNT(\*) 的过程中，时间主要消耗在 Sending data 这个状态上。为了更清晰地看到排序结果，可以查询 INFORMATION_SCHEMA.PROFILING 表 并按照时间做个 DESC 排序。

```mysql
mysql> set @query_id :=6;
Query OK, 0 rows affected (0.00 sec)

mysql> select 
			state, sum(duration) as total_r, 
			round(100 * sum(duration) / (
        		select sum(duration) from information_schema.profiling where query_id=@query_id
    		), 2) as Pct_R, 
    		count(*) as calls, 
    		sum(duration) / count(*) as 'R/Call' 
    from INFORMATION_SCHEMA.profiling 
    where query_id=@query_id group by state order by total_r desc;
+--------------------------------+----------+-------+-------+--------------+
| state                          | total_r  | Pct_R | calls | R/Call       |
+--------------------------------+----------+-------+-------+--------------+
| Sending data                   | 0.031881 | 98.13 |     1 | 0.0318810000 |
| Opening tables                 | 0.000264 |  0.81 |     1 | 0.0002640000 |
| starting                       | 0.000125 |  0.38 |     2 | 0.0000625000 |
| freeing items                  | 0.000081 |  0.25 |     1 | 0.0000810000 |
| preparing                      | 0.000030 |  0.09 |     1 | 0.0000300000 |
| waiting for handler commit     | 0.000018 |  0.06 |     1 | 0.0000180000 |
| statistics                     | 0.000016 |  0.05 |     1 | 0.0000160000 |
| cleaning up                    | 0.000013 |  0.04 |     1 | 0.0000130000 |
| end                            | 0.000012 |  0.04 |     1 | 0.0000120000 |
| init                           | 0.000011 |  0.03 |     1 | 0.0000110000 |
| System lock                    | 0.000010 |  0.03 |     1 | 0.0000100000 |
| closing tables                 | 0.000009 |  0.03 |     1 | 0.0000090000 |
| optimizing                     | 0.000005 |  0.02 |     1 | 0.0000050000 |
| Executing hook on transaction  | 0.000004 |  0.01 |     1 | 0.0000040000 |
| checking permissions           | 0.000004 |  0.01 |     1 | 0.0000040000 |
| query end                      | 0.000004 |  0.01 |     1 | 0.0000040000 |
| executing                      | 0.000002 |  0.01 |     1 | 0.0000020000 |
+--------------------------------+----------+-------+-------+--------------+
17 rows in set, 18 warnings (0.01 sec)
```

​		在获取到最消耗时间的线程状态后，MySQL 支持进一步选择 all、cpu、block io、context switch、page faults 等明细类型来查看MySQL在使用什么资源上耗费了过高的时间，例如，选择查看CPU 的耗费时间：

```mysql
mysql> show profile cpu for query 6;
+--------------------------------+----------+----------+------------+
| Status                         | Duration | CPU_user | CPU_system |
+--------------------------------+----------+----------+------------+
| starting                       | 0.000119 | 0.000000 |   0.000000 |
| Executing hook on transaction  | 0.000004 | 0.000000 |   0.000000 |
| starting                       | 0.000006 | 0.000000 |   0.000000 |
| checking permissions           | 0.000004 | 0.000000 |   0.000000 |
| Opening tables                 | 0.000264 | 0.000000 |   0.000000 |
| init                           | 0.000011 | 0.000000 |   0.000000 |
| System lock                    | 0.000010 | 0.000000 |   0.000000 |
| optimizing                     | 0.000005 | 0.000000 |   0.000000 |
| statistics                     | 0.000016 | 0.000000 |   0.000000 |
| preparing                      | 0.000030 | 0.000000 |   0.000000 |
| executing                      | 0.000002 | 0.000000 |   0.000000 |
| Sending data                   | 0.031881 | 0.031250 |   0.015625 |
| end                            | 0.000012 | 0.000000 |   0.000000 |
| query end                      | 0.000004 | 0.000000 |   0.000000 |
| waiting for handler commit     | 0.000018 | 0.000000 |   0.000000 |
| closing tables                 | 0.000009 | 0.000000 |   0.000000 |
| freeing items                  | 0.000081 | 0.000000 |   0.000000 |
| cleaning up                    | 0.000013 | 0.000000 |   0.000000 |
+--------------------------------+----------+----------+------------+
18 rows in set, 1 warning (0.00 sec)
```

​		能够发现 Sending data 状态下，时间主要消耗在 CPU上了。

​		对比MyISAM 表的 COUNT(\*) 操作，也创建了一个同样表结构的 MyISAM 表，数据量也完全一致：

```mysql
mysql> create table payment_myisam like payment;
Query OK, 0 rows affected (0.04 sec)

mysql> alter table payment_myisam engine=myisam;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> insert into payment_myisam select * from payment;
Query OK, 16049 rows affected (0.16 sec)
Records: 16049  Duplicates: 0  Warnings: 0
```

​		同样执行 count(\*) 操作，检查 profile :

```mysql
mysql> select count(*) from payment_myisam;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.00 sec)


mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec)

mysql> show profiles \G;
....
*************************** 14. row ***************************
Query_ID: 23
Duration: 0.00027050
   Query: select count(*) from payment_myisam
15 rows in set, 1 warning (0.00 sec)   
 
 
mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec) 
```

​		从 profile 的结果能够看出，InnoDB 引擎的表在 count(\*) 时经历了 Sending data 状态，存在访问数据的过程，而 myisam 引擎的表在 executing 之后直接就结束查询，完全不需要访问数据。

​		show profile 能够在做 SQL 优化时帮助我们了解事件都耗费在哪里去了。而MySQL 5.6 之后则通过 trace 文件进一步向我们展示了优化器是如何执行计划的。

> 注意：在MySQL5.7中，profile 已经不建议使用，而使用 performance schema中的一系列性能视图来替代。



### 15.1.5 通过 trace 分析优化器如何选择执行计划

​		MySQL 从5.6 版本开始提供了对sql的跟踪 trace，通过 trace 文件能够进一步了解为什么优化器选择 A 执行计划而不选择 B执行计划，帮助我们更更好的理解优化器行为。

​		使用方式：首先打开 trace，设置格式为 JSON，设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整显示。

```mysql
mysql> set optimizer_trace='enabled=on', end_markers_in_json=on;
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_trace_max_mem_size=1000000;
Query OK, 0 rows affected (0.00 sec)
```

​		接下来执行想做trace 的sql 语句，例如，想了解租赁表 rental 中库存编号 inventory_id 为 4466 的电影拷贝在出租日期 rental_date 为 2005-05-25 4:00:00 ~5:00:00 出租的记录：

```mysql
mysql> select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466;
+-----------+
| rental_id |
+-----------+
|        39 |
+-----------+
1 row in set (0.02 sec)
```

​		然后检查 INFORMATION_SCHEMA.OPTIMIZER_TRACE 就可以知道 MySQL是如何执行sql语句的：

​		最后会输出一个格式如下的跟踪文件：

```mysql
mysql> select * from information_schema.optimizer_trace\G;
*************************** 1. row ***************************
                            QUERY: select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466
                            TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `rental`.`rental_id` AS `rental_id` from `rental` where ((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "((`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": {
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`rental`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
              {
                "table": "`rental`",
                "field": "inventory_id",
                "equals": "4466",
                "null_rejecting": false
              }
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`rental`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 16008,
                    "cost": 1699.9
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "rental_date",
                      "usable": true,
                      "key_parts": [
                        "rental_date",
                        "inventory_id",
                        "customer_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_inventory_id",
                      "usable": true,
                      "key_parts": [
                        "inventory_id",
                        "rental_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_customer_id",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_fk_staff_id",
                      "usable": false,
                      "cause": "not_applicable"
                    }
                  ] /* potential_range_indexes */,
                  "best_covering_index_scan": {
                    "index": "rental_date",
                    "cost": 1629.1,
                    "chosen": true
                  } /* best_covering_index_scan */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "rental_date",
                        "usable": false,
                        "cause": "prefix_not_const_equality"
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "rental_date",
                        "ranges": [
                          "0x9975b24000 <= rental_date <= 0x9975b25000"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false,
                        "using_mrr": false,
                        "index_only": true,
                        "rows": 10,
                        "cost": 2.0254,
                        "chosen": true
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "ranges": [
                          "4466 <= inventory_id <= 4466"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 5,
                        "cost": 6.51,
                        "chosen": false,
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "rental_date",
                      "rows": 10,
                      "ranges": [
                        "0x9975b24000 <= rental_date <= 0x9975b25000"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 10,
                    "cost_for_plan": 2.0254,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`rental`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "access_type": "ref",
                      "index": "idx_fk_inventory_id",
                      "rows": 5,
                      "cost": 5.5,
                      "chosen": true
                    },
                    {
                      "rows_to_scan": 10,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "rental_date"
                      } /* range_details */,
                      "resulting_rows": 10,
                      "cost": 3.0254,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 10,
                "cost_for_plan": 3.0254,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`rental`",
                  "attached": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`rental`",
                "original_table_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
                "final_table_condition   ": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
              }
            ] /* finalizing_table_conditions */
          },
          {
            "refine_plan": [
              {
                "table": "`rental`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0
          INSUFFICIENT_PRIVILEGES: 0
1 row in set (0.01 sec)
```

​		文件里面记录很多信息，包括访问表的路径、行数、成本等，来帮助读者对执行计划的选择过程进行分析。



### 15.1.6 确定文体并采取相应的优化措施

​		经过上面的步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措施，进行优化以提高执行的效率。

​		上面某个例子可以确认是由于对客户表 customer 的全表扫描导致效率不理想，那么对客户表 customer 的 email 字段创建索引，具体如下：

```mysql
mysql> create index idx_email on customer(email);
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		创建索引后，再看下这条语句的执行计划，具体如下：

```mysql
mysql>  explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: const
possible_keys: PRIMARY,uk_email,idx_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 28
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.01 sec)
```

​		可以发现，建立索引后对客户表 customer 需要扫描的行数明显减少（从599 行减少到1 行）。可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候，这种优势更为明显。



## 15.2 索引问题

​		索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的SQL性能问题。本节将详细讨论MySQL 中索引的分类、存储和使用方法。

### 15.2.1 索引的存储分类

​		索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MySQL目前提供了以下4种索引。

1. B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。
2. HASH索引：只有 Memory/NDB 引擎支持，使用场景简单。
3. R-Tree 索引（空间索引）：空间索引是MyISAM 的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍
4. Full-text（全文索引）：全文索引也是MyISAM 的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL 5.6 版本开始提供对全文索引的支持。

MySQL 目前版本（8.0.11）还不支持函数索引（8.0.13 开始已经支持），但是可以通过两种方式实现函数索引的功能。

（1）前缀索引，即对列的前面某一部分进行索引。例如标题 title 字段，可以只取 title 的前 10 个字符进行索引，这个特性可以大大缩小索引文件的大小，但前缀索引也有缺点，在排序 order by 和 分组 操作的时候无法使用。用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。

​		下面是创建前缀索引的一个例子：

```mysql
mysql> create index idx_title_1 on film(title(10)) ;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

（2）虚拟列索引。在Oracle 等大多商业数据库种，早已支持函数索引，但MySQL一直没有实现这个功能。在MySQL5.7之后，可以通过创建虚拟列索引的方式来实现函数索引的功能，如下例所示：

​		创建表sql

```mysql
mysql> create table salaries  (emp_no int(11),salary int(11),from_date date, to_date date, primary key (emp_no,from_date));
Query OK, 0 rows affected (0.05 sec)
```



​		在表 salaries 中执行如下 sql

```mysql
mysql> select * from salaries where round(salary/1000) < 10;
```

​		表地定义如下：

```mysql
mysql> desc salaries;
+-----------+---------+------+-----+---------+-------+
| Field     | Type    | Null | Key | Default | Extra |
+-----------+---------+------+-----+---------+-------+
| emp_no    | int(11) | NO   | PRI | NULL    |       |
| salary    | int(11) | YES  |     | NULL    |       |
| from_date | date    | NO   | PRI | NULL    |       |
| to_date   | date    | YES  |     | NULL    |       |
+-----------+---------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

​		此时，直接在 salary 上创建 索引并不会被这个 sql 使用。这里创建一个虚拟列 salary_by_lk：

```mysql
mysql> alter table salaries add column salary_by_lk int generated always as (round(salary/1000));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		然后在这个虚拟列上创建索引：

```mysql
mysql> alter table salaries add key odx_salary_by_lk(salary_by_lk);
Query OK, 0 rows affected (0.03 sec)
```

​		此时观察执行计划，显示新创建的虚拟列索引已经被使用：

```mysql
mysql> desc select count(1) from salaries where round(salary/1000)<10 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: salaries
   partitions: NULL
         type: range
possible_keys: odx_salary_by_lk
          key: odx_salary_by_lk
      key_len: 5
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

```

​		实际执行后，SQL 的执行时间从 8s 降到了 0.2 s。



下面比较MyISAM、InnoDB、Memory 这三个常用引擎支持的索引类型。

| 索引           | MyISAM 引擎 | InnoDB 索引 | Memory 索引 |
| -------------- | ----------- | ----------- | ----------- |
| B-Tree 索引    | 支持        | 支持        | 支持        |
| HASH 索引      | 不支持      | 不支持      | 支持        |
| R-Tree 索引    | 支持        | 不支持      | 不支持      |
| Full-text 索引 | 支持        | 支持        | 不支持      |

​		比较常用到的索引就是 B-Tree 索引和 Hash索引。Hash索引相对简单，只有 Memory/NDB 引擎支持完全的Hash索引，InnoDB 存储引擎在MySQL 5.7 中支持自适应的 Hash索引。所谓自适应，就是MySQL 根据数据的访问频率和模式为某些热点页自动创建Hash索引，索引由 buffer pool 中的B-Tree 来自动生成，效率很高，这个特性由参数 innodb_adaptive_hash_index来控制，默认是打开的。

​		Hash索引适用于 Key-Value 查询，通过Hash索引要比通过B-Tree索引查询更迅速；Hash索引不适用范围查询，例如 <.><=,>= 这类操作。如果使用 Memory/NDB 引擎并且 where 条件不使用 ”=“ 进行索引列，那么就不会用到索引。Memory/Heap 引擎只有在 ”=“ 的条件下才会使用索引。

​		B-Tree 索引比较复杂，下面将详细分析MySQL是如何利用 B-Tree 索引的。



### 15.2.2 MySQL 如何使用索引

​		B-Tree 索引是最常见的索引，构造类似二叉树，能根据键值提供一行或者一个行集的快速访问，通常只需要很少的读操作就可以找到正确的行。不过，需要注意B-Tree索引中的B不代表二叉树（binary），而是代表平衡树（balanced）。B-Tree并不是一颗二叉树。

​		为了避免混淆，重命名租赁表 rental 上的索引 rental_date 为 idx_rental_date:

```mysql
mysql> alter table rental rename index rental_date to idx_rental_date;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

1. MySQL中能够使用索引的典型场景

   （1）匹配全值（Mathch the full value），对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。例如，租赁表 rental 中通过指定出租日期 rental_date + 库存编号 inventory_id + 客户编号 customer_id 的组合条件 进行查询，从执行计划的 key 和 extra 两个字段的值看到优化器选择了复合索引 idx_rental_date:

   ```mysql
   mysql> explain select * from rental where rental_date='2005-05-25 17:22:10' and inventory_id=373 and customer_id=343 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: const
   possible_keys: idx_rental_date,idx_fk_inventory_id,idx_fk_customer_id
             key: idx_rental_date
         key_len: 10
             ref: const,const,const
            rows: 1
        filtered: 100.00
           Extra: NULL
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		explain 输出结果中字段type的值为const，表示是常量；字段key的值为idx_rental_date,表示优化器选择索引idx_rental_date 进行扫描。

   （2）匹配值的范围查询（Mathch a range of values）,对索引的值能够进行范围查找。例如，检索租赁表 rental中客户编号 customer_id 在指定范围内的记录：

   ```mysql
   mysql> explain select * from rental where customer_id > 373 and customer_id <400 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: range
   possible_keys: idx_fk_customer_id
             key: idx_fk_customer_id
         key_len: 2
             ref: NULL
            rows: 683
        filtered: 100.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		类型 type 为range 说明优化器选择范围查询，索引 key 为 idx_fx-customer_id 说明优化器选择索引idx_fx_customer_id 来加速访问，注意到这个例子中Extra 列为 Using where，表示优化器除了用索引来加速访问之外，还需要根据索引回表查询数据。

   （3）匹配最左前缀（Match a leftmost prefix），仅仅使用索引中的最左边列进行查找，比如在 col1+col2+col3 字段上的联合索引能够被包含col1、（col1+col2）、（col1+col2+col3） 的等值查询利用到，可是不能够被 col2、（col2+col3）的等值查询利用到；以支付表 payment 为例，如果查询条件中仅包含索引的第一列支付日期 payment_date 和 索引 的第三列更新时间 last_update 的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_last_update的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_date 进行条件过滤：

   ````mysql
   mysql> alter table payment add index idx_payment_date (payment_date, amount, last_update);
   Query OK, 0 rows affected (0.14 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   
   mysql> explain select * from payment where payment_date='2006-02-14 15:16:03' and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 5
             ref: const
            rows: 182
        filtered: 10.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ````

   ​		但是，如果仅仅选择复合索引 idx_payment_date 的第二列支付金额amount和 第三列更新时间 last_update_date 进行查询时，那么执行计划显示并不会利用到索引 idx_payment_date:

   ```mysql
   mysql> explain select * from payment where amount = 3.98 and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 1.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		最左匹配原则可以算是 MySQL中B-Tree 索引使用首要原则。

   （4）仅仅对索引进行查询（Index only query），当查询的列都在索引的字段中时，查询的效率更高；对比上一个例子使用 select *, 本次选择查询的字段都包含在索引 idx_payment_date 中时，能够看到查询计划有一点变动：

   ```mysql
   mysql> explain select  last_update from payment where payment_date='2006-02-14 15:16:03' and amount = 3.98 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 8
             ref: const,const
            rows: 8
        filtered: 100.00
           Extra: Using index
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		Extra 部分变成了 Using index ，也就意味着，现在直接访问索引就足够获取到所需要的数据，不需要通过索引回表，Using index 也就是平时说的覆盖索引扫描。只访问必须访问的数据，在一般情况下，减少不必要的数据访问能够提升效率。

（5）匹配列前缀（match a column prefix）,仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。例如，现在需要查询出标题 title 是以 AFRICAN 开头的电影信息，从执行计划能够清楚看到， idx_title_desc_part 索引被利用上了：

```mysql
mysql> create index idx_title_desc_part on film_text (title(10), description(20));
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select title from film_text where title like 'AFRICAN%'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_text
   partitions: NULL
         type: range
possible_keys: idx_title_desc_part,idx_title_description
          key: idx_title_desc_part
      key_len: 42
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		Extra 值为 Using where 表示优化器需要通过索引回表查询数据。

（6）能够实现索引匹配部分精确而其他部分进行范围匹配（match one part exactly and match a range on another part）。例如，需要查询出租日期 rental_date 为指定日期且客户编号 customer_id 为指定范围的库存：

```mysql
mysql> explain select inventory_id from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using where; Using index
1 row in set, 1 warning (0.01 sec)
```

​		类型type 为 range 说明优化器选择范围查询，索引 key 为 idx_rental_date 说明优化器选择索引 idx_rental_date 帮助加速查询，同时由于子=只查询索引字段 inventory_id 的值，所以在extra 部分能看到 using index ，表示查询使用了覆盖索引扫描。

（7）如果列名是索引，那么使用 column_name is null 就会使用索引（区别于 Oracle）。例如，查询支付表 payment 的租赁编号 rental_id 字段为空的记录就用到了索引：

```mysql
mysql> explain select * from payment where rental_id is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: fk_payment_rental
          key: fk_payment_rental
      key_len: 5
          ref: const
         rows: 5
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（8）MySQL5.6引入了 Index Condition Pushdown (ICP) 的特性，进一步优化了查询。Pushdown 表示操作下放，某些情况下的条件过滤操作下放到存储引擎。

​		例如，查询租赁表rental 中租赁时间 rental_date 在某一指定时间点且客户编号 customer_id 在指定范围内的数据，MySQL5.5/5.1的执行计划显示：优化器首先使用复合索引 idx_rental_date 的首字段 rental_date 过滤出符合条件 rental_date='2006-02-14 15:16:03' 的记录（执行计划中的key 字段值显示为 idx_rental_date），然后根据复合索引 idx_rental_date 回表获取记录后，最终根据条件 customer_id >= 300 and customer_id <= 400 来过滤出最后的查询结果（执行计划中 Extra 字段值显示为 Using where）。

```mysql
mysql> select version();
+-----------+
| version() |
+-----------+
| 8.0.16    |
+-----------+
1 row in set (0.00 sec)

mysql> explain select * from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

​		MySQL5.7 上做同样的案例，能够发现 Explain 执行计划 的Extra 部分从using where 变成了 Using index condition 的提示

​		Using index condition 表示MySQL使用了ICP 来进一步优化查询，在检索的时候，把条件 customer_id 的过滤操作下推到存储引擎层来完成，这样能够降低不必要的IO访问。



2. 存在索引但不能使用索引的典型场景

   ​	有些时候虽然有索引，但是不被优化器选择使用。下面列举几个不能使用索引的常见场景。

   （1）以 % 开头的 LIKE 查询不能利用 B-Tree 索引，执行计划中key 的值为NULL 表示没有用到索引。

   ```mysql
   mysql> explain select * from actor where last_name like '%NI%'\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 200
        filtered: 11.11
           Extra: Using where
   1 row in set, 1 warning (0.04 sec)
   ```

   ​		因为 B-Tree 索引的结构，所以以 % 开头的查询很自然就没法利用索引了，一般都推荐使用全文索引（Filltext）来解决类似的全文检索问题。或者考虑利用InnoDB的表都是聚簇表的特点，采取一种轻量级别的解决方式：一般情况下，索引都会比表小，扫描索引要比扫描表更快（某些特殊的情况下，索引比表更大），而 InnoDB表上二级索引 idx_last_name 实际上存储字段 last_name 还有主键 actor_id，那么理想的访问方式应该是首先扫描二级索引 idx_last_name 获得满足条件 last_name like '%NI%' 的主键 actor_id 列表，之后根据主键回表去检索记录，这样访问避开了全表扫描演员表 actor 产生的大量IO 请求。验证一下：

   ```mysql
   mysql> explain select * from (select actor_id from actor where last_name like '%NI%')a,actor b where a.actor_id=b.actor_id\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: index
   possible_keys: PRIMARY
             key: idx_actor_last_name
         key_len: 182
             ref: NULL
            rows: 200
        filtered: 11.11
           Extra: Using where; Using index
   *************************** 2. row ***************************
              id: 1
     select_type: SIMPLE
           table: b
      partitions: NULL
            type: eq_ref
   possible_keys: PRIMARY
             key: PRIMARY
         key_len: 2
             ref: sakila.actor.actor_id
            rows: 1
        filtered: 100.00
           Extra: NULL
   2 rows in set, 1 warning (0.00 sec)
   ```

   ​		从执行计划可以看到，内层查询的Using index 代表索引覆盖扫描，之后通过主键 join 操作去演员表actor 中获取最终查询结果，理论上是能够比直接全表扫描更快一些。

   （2）数据类型出现隐式转换的时候也不会使用索引，特别是当列类型是字符串时，那么一定记得在 where 条件中把字符常量值用引号引起来，否则即便这个列上有索引，MySQL 也不会用到，因为MySQL默认把输入的常量值进行转换以后才进行检索。例如，演员表actor 中的姓氏字段 last_name 是字符型的，但是SQL 语句中的条件值 1 是 一个数值类型，因此即便存在索引 idx_last_name,MySQL也不能正确地用上索引，而是继续全表扫描：

   ```mysql
   mysql> explain select * from actor where last_name=1 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ALL
   possible_keys: idx_actor_last_name
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 200
        filtered: 10.00
           Extra: Using where
   1 row in set, 3 warnings (0.00 sec)
   ```

   ​		加上引号之后，再次检查执行计划，就发现使用上索引了：

   ```mysql
   mysql> explain select * from actor where last_name='1' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: actor
      partitions: NULL
            type: ref
   possible_keys: idx_actor_last_name
             key: idx_actor_last_name
         key_len: 182
             ref: const
            rows: 1
        filtered: 100.00
           Extra: NULL
   1 row in set, 1 warning (0.00 sec)
   ```

   （3）复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则 Leftmost， 是不会使用复合索引的：

   ```mysql
   mysql> explain select * from payment where amount= 3.98 and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 1.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   （4）如果MySQL估计使用索引比全表扫面更慢，则不使用索引。例如，查询以“S” 开头的电影标题，需要返回的记录比较大，MySQL就预估索引扫描还不如全表扫描更快：

   ```mysql
   mysql> update film_text set title=concat('S', title);
   Query OK, 1000 rows affected (0.17 sec)
   Rows matched: 1000  Changed: 1000  Warnings: 0
   
   mysql> explain select * from film_text where title like 'S%' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: film_text
      partitions: NULL
            type: ALL
   possible_keys: idx_title_desc_part,idx_title_description
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 1000
        filtered: 100.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		在MySQL5.7 版本中，能够通过 Trace清晰地看到优化器选择地过程，全表扫描 table scan需要访问的纪录 rows 为 1000，代价cost 计算为233.53：

   ​		而对应 idx_title_desc_part 索引过滤条件时，优化器预估需要返回 998 条记录，访问代价 cost 为 1198.6,远高于全表扫描地代价，索引优化器倾向于选择全表扫面

   ​		更换查询地值为一个选择率更高的值，就能发现优化器更倾向于选择索引扫描：

   ```mysql
   mysql> explain select * from film_text where title like 'Sw%'\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: film_text
      partitions: NULL
            type: range
   possible_keys: idx_title_desc_part,idx_title_description
             key: idx_title_desc_part
         key_len: 42
             ref: NULL
            rows: 43
        filtered: 100.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		同样通过trace 能够看到，title like ‘Sw%’ 优化器预估需要返回66条记录，远小于全表扫面，所以优化器倾向于选择索引扫描。

   ​		也就是在查询时，筛选性越高越容易使用索引，筛选性越低越不容易使用索引。

   （5）用 or 分割开的条件，如果 or 前的条件中有索引，而后面的列中没有索引，那么涉及的索引都不会被用到，例如：

   ```mysql
   mysql> explain select * from payment where customer_id = 203 or amount = 3.96\G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: idx_fk_customer_id
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 10.15
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		因为 or 后面的条件列中没有索引，那么后面的查询肯定要走全表扫描，在存在全表扫描的情况下，就没有必要多一次索引扫描增加I/O访问，一次全表扫描过滤条件就足够了。

   

   ### 15.2.3 查看索引使用情况

   ​		如果索引正在工作，Handler_read_key 的值就会很高，这个值代表了一个行被索引值读的次数，很低的值表明增加索引得到的性能改善不高，因为索引并不经常使用。

   ​		Handler_read_rnd_next 的值高意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果正在进行大量的表扫描，Handler_read_rnd_next 的值较高，则通常说明表索引不正确，或写入的查询没有利用索引，具体如下：

   ```mysql
   mysql> show status like 'Handler_read%';
   +-----------------------+-------+
   | Variable_name         | Value |
   +-----------------------+-------+
   | Handler_read_first    | 1     |
   | Handler_read_key      | 69    |
   | Handler_read_last     | 0     |
   | Handler_read_next     | 50    |
   | Handler_read_prev     | 0     |
   | Handler_read_rnd      | 0     |
   | Handler_read_rnd_next | 1001  |
   +-----------------------+-------+
   7 rows in set (0.01 sec)
   ```

   

   ## 15.3 两个简单实用的优化方法

   ### 15.3.1 定期分析表和检查表

   ​		分析表的语法如下：

   ```mysql
   ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
   ```

   ​		本语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL 能够生成正确得执行计划。如果用户感觉实际执行计划并不是预期得执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM、BDB和InnoDB表有作用。对于MyISAM表，本语句与使用 myisamchk -a相当，下例中对表 sales 做了表分析：

   ```mysql
   mysql> analyze table payment;
   +----------------+---------+----------+----------+
   | Table          | Op      | Msg_type | Msg_text |
   +----------------+---------+----------+----------+
   | sakila.payment | analyze | status   | OK       |
   +----------------+---------+----------+----------+
   1 row in set (0.04 sec)
   ```

   ​		检查表得语法如下：

   ```mysql
   CHECK TABLE tbl_name [, tbl_name] ... [option] ... option={QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
   ```

   ​		检查表的作用是检查一个或多个表是否有错误。CHECK TABLE 对 MyISAM 和InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新，例如：

   ```mysql
   mysql> check table payment_myisam;
   +-----------------------+-------+----------+----------+
   | Table                 | Op    | Msg_type | Msg_text |
   +-----------------------+-------+----------+----------+
   | sakila.payment_myisam | check | status   | OK       |
   +-----------------------+-------+----------+----------+
   1 row in set (0.02 sec)
   ```

   

   ​	CHECK TABLE 也可以检查试图是否有错误，比如在视图定义中被引用得表已不存在，下面给出一个示例。

   （1）首先创建一个视图：

   ```mysql
   mysql> create view v_payment_myisam as select * from payment_myisam;
   Query OK, 0 rows affected (0.02 sec)
   ```

   （2）然后 CHECk 一下该视图，发现没有问题：

   ```mysql
   mysql> check table v_payment_myisam;
   +-------------------------+-------+----------+----------+
   | Table                   | Op    | Msg_type | Msg_text |
   +-------------------------+-------+----------+----------+
   | sakila.v_payment_myisam | check | status   | OK       |
   +-------------------------+-------+----------+----------+
   1 row in set (0.01 sec)
   ```

   （3）现在删除掉视图依赖的表：

   ```mysql
   mysql> drop table payment_myisam;
   Query OK, 0 rows affected (0.03 sec)
   ```

   （4）再来CHECK 一下刚才的视图，发现报错了，并且提示出错的原因是 Table sakila.payent_myisam 不存在了：

   ```mysql
   mysql> check table v_payment_myisam \G;
   *************************** 1. row ***************************
      Table: sakila.v_payment_myisam
         Op: check
   Msg_type: Error
   Msg_text: View 'sakila.v_payment_myisam' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
   *************************** 2. row ***************************
      Table: sakila.v_payment_myisam
         Op: check
   Msg_type: error
   Msg_text: Corrupt
   2 rows in set (0.00 sec)
   ```




### 15.3.2 定期优化表

​		优化表的语法如下：

```mysql
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
```

​		如果已经删除了表的一大部分，或者如果已经对含有可变长度行的表（含有 VARCHAR 、BLOB 或 TEXT 列的表）进行了很多更改，则应使用 OPTIMIZE TABLE 命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对 MyISAM、BDB 和 InnoDB 表起作用。命令执行期间 MyISAM 表会全程锁表，而InnoDB 表则会将优化命令转换为重建表和分析表两个操作，加锁时间也仅仅在整个工作的prepare 和 commit 期间做短暂的加锁工作，对于表的读写几乎没有影响。

​		以下例子显示了优化表 payment_myisam 的过程：

```mysql
mysql> optimize table payment_myisam;
+-----------------------+----------+----------+-----------------------------+
| Table                 | Op       | Msg_type | Msg_text                    |
+-----------------------+----------+----------+-----------------------------+
| sakila.payment_myisam | optimize | status   | Table is already up to date |
+-----------------------+----------+----------+-----------------------------+
1 row in set (0.00 sec)
```

​		对于InnoDB 引擎的表来说，通过设置 innodb_file_per_table 参数，设置InnoDB 为独立表空间模式，这样每个数据库的每个表都会生成一个独立的 ibd文件，用于存储表的数据和索引，这样可以一定程度上减轻InnoDB 表的空间回收问题。另外，在删除大量数据后，InnoDB 表可以通过alter table 但是不修改引擎的方式来回收不用的空间：

```mysql
mysql> alter table payment engine=innodb;
Query OK, 0 rows affected (0.93 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

> 注意：AMALYZE、CHECK、OPTIMIZE、ALTER TABLE 执行期间将对表进行锁定，因此一定注意要在数据库不繁忙的时候执行相关操作。



## 15.4 常用SQL的优化

​		前面已经介绍了MySQL中是如何通过索引来优化查询的。在日常开发中，除了使用查询外，我们还会使用一些其他的常用sql，比如 insert、group by等。下面将对于这些 sql语句介绍一些优化的方法。

### 15.4.1 大批量插入数据

​		当用 load命令导入数据的时候，适当的设置可以提高导入的速度。

​		对于 MyISAM 存储引擎的表，可以通过以下方式快速的导入大量的数据。

```mysql
ALTER TABLE tbl_name DISABLE KEYS;
loading the data
ALTER TABLE tbl_name ENABLE KEYS;
```

​		DISABLE KEYS 和 ENABLE KEYS 用来打开或者关闭 MyISAM 表唯一索引的更新。在导入大量的数据到一个非空的 MyISAM 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量数据到一个空的MyISAM 表，默认就是先导入数据然后才创建索引的，所以不用进行设置。

> load data 用法 https://www.cnblogs.com/yyy-blog/p/11073855.html



使用InnoDB类型的表，这种方式并不能提高导入数据的效率，可以有以下几种方式提高 InnoDB 表的导入效率。

（1）因为InnoDB 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。

（2）在导入数据前执行 SET UNIQUE_CHECKS=0,关闭唯一性校验；在导入结束后执行 SET UNIQUE_CHECKS=1, 恢复唯一性校验，可以提高导入的效率。

（3）如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。

### 15.4.2 优化INSERT 语句

​		当进行数据 insert 的时候，可以考虑采用以下几种优化方式：

+ 如果同时从同一客户插入多行时:

  ```mysql
  insert into test values (1,2),(1,3)...
  ```

+ 如果从不同客户插入多行时，可以使用 INSERT DELAYED 语句得到更高的速度。DELAYED的含义是让 INSERT 语句马上执行，其实数据都被放在内存队列中，并没有真正写入磁盘，这比每条语句分别插入要快很多；LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完成后才进行插入。

+ 将索引文件和数据文件分别放在不同的磁盘上存放（利用建表中的选项）。

+ 如果进行批量插入，可以通过增加变量值  bulk_insert_buffer_size 的方法来提高速度，但是这种方式在只能对MyISAM表使用。

+ 当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍。



### 15.4.3 优化 ORDER BY 语句

​		优化 order by 语句之前，首先来了解一下MySQL中的排序方式。先看 customer表上的索引情况：

```mysql
mysql> show index from customer \G
*************************** 1. row ***************************
        Table: customer
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: customer_id
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 2. row ***************************
        Table: customer
   Non_unique: 0
     Key_name: uk_email
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 3. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_fk_store_id
 Seq_in_index: 1
  Column_name: store_id
    Collation: A
  Cardinality: 2
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 4. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_fk_address_id
 Seq_in_index: 1
  Column_name: address_id
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 5. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_last_name
 Seq_in_index: 1
  Column_name: last_name
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null:
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
*************************** 6. row ***************************
        Table: customer
   Non_unique: 1
     Key_name: idx_email
 Seq_in_index: 1
  Column_name: email
    Collation: A
  Cardinality: 599
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment:
Index_comment:
      Visible: YES
   Expression: NULL
6 rows in set (0.04 sec)
```

#### 1. MySQL中有两种排序方式

​		第一种通过有序索引顺序扫描直接返回有序数据，这种方式在使用 explain 分析查询的时候显示为 Using Index，不需要额外的排序，操作效率较高，例如：

```mysql
mysql> explain select customer_id from customer order by store_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_fk_store_id
      key_len: 1
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

​		第二种是通过对返回数据进行排序，也就是通常说的 Filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 Filesort 排序。Filesort 并不代表通过磁盘文件进行排序，而只是说明进行了一个排序操作，至于排序操作是否使用了磁盘文件或临时表等，则取决于 mysql 服务器对排序参数的设置和需要排序数据的大小。例如，按照商店 store_id 排序返回所有客户记录时，出现了对全表扫描的结果的排序：

```mysql
mysql> explain select * from customer order by store_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		又如，只需要获取商店store_id 和顾客 email 信息时，对表 customer 的扫描就被对覆盖索引 idx_storeid_email 扫描替代，此时虽然只访问了索引就足够，但是在索引 idx_storeid_email 上发生了一次排序操作，所以执行计划中仍然有 Filesort。

```mysql
mysql> alter table customer add index idx_storeid_email(store_id, email);
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select store_id,email, customer_id from customer order by email \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_storeid_email
      key_len: 204
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using index; Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		Filesort 是通过相应的排序算法，将取得的数据在 sort_buffer_size 系统变量设置的内存排序区中进行排序，如果内存装载不下，它就会将磁盘上的数据进行分块，再对各个数据块进行排序，让后将各个快合并成有序的结果集。sort_buffer_size 设置的排序区是每个线程独占的，所以同一时刻，MySQL中存在多个 sort buffer 排序区。

​		了解了 MySQL排序的方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和 order by 使用相同的索引，并且order by 的顺序和索引顺序相同，并且 order by 的字段都是升序或者降序，否则肯定需要额外的排序操作，这样就会出现 Filesort。

​		例如查询商店编号 store_id 为1 ，按照 email 逆序排序的记录 主键 customer_id 时，优化器使用扫描索引 idx_storeid_email 直接返回 排序完毕的记录：

```mysql
mysql> explain select store_id, email, customer_id from customer where store_id=1 order by email desc \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: ref
possible_keys: idx_fk_store_id,idx_storeid_email
          key: idx_storeid_email
      key_len: 1
          ref: const
         rows: 326
     filtered: 100.00
        Extra: Backward index scan; Using index
1 row in set, 1 warning (0.00 sec)
```

​		而查询商店编号 store_id 大于等于 1 小于等于 3 ，按照email排序的记录主键customer_id 的时候，由于优化器评估使用 索引 idx_storeid_email 进行范围扫描代价 cost 最低，所以最终对索引扫描的结果，进行了额外的按照 ename 逆序排序操作：

```mysql
mysql> explain select store_id,email, customer_id from customer where store_id >=1 and store_id <=3 order by email desc \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: index
possible_keys: idx_fk_store_id,idx_storeid_email
          key: idx_storeid_email
      key_len: 204
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using where; Using index; Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		总结，下列sql可以直接使用索引：

```mysql
select * from tabname order by key_part1,key_part2,...;
select * from tabname where key_part1=1 order by key_part1 desc,key_part2 desc;
select * from tabname order by key_part1 desc, key_part2 desc;
```

​		但是以下几种情况下则不使用索引：

```mysql
# order by 的字段混合 asc 和 desc
select * from tabname order by key_part1 desc,key_part2 asc;
# 用于查询的关键字与order by 中使用的不相同
select * from tabname where key2=constant order by key1;
# 对不同关键字使用 order by
select * from tabname order by key1,key2;
```

#### 2. Filesort 优化

​		通过创建合适的索引能够减少 Filesort 出现，但是在某些情况下，条件限制不能让 Filesort 消失，那就需要想办法加快 Filesort 的操作。对于 Filesort ，MySQL有两种排序算法。

1. 两次扫描算法（Two Passes）：首先根据条件取出排序字段和行指针信息，之后在排序区 sort buffer 中排序，如果排序区 sort buffer 不够，则在临时表 Tempporary Table 中存储排序结果。完成排序后根据行指针回表读取记录。该算法是 MySQL4.1 之前采用的算法，需要两次访问数据，第一次获取排序字段和行指针信息，第二次根据行指针获取记录，尤其是第二次读取操作可能导致大量随机I/O操作；优点排序的时候内存开销较少。

2. 一次扫描算法（Single Pass）：一次性取出满足条件的行的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集，排序的时候内存开销比较大，但是排序效率比两次扫描要高。

   ​	

​        MySQL通过比较系统变量max_length_for_sort_data 的大小和 Query 语句取出的字段总大小来判断使用那种排序算法。如果max_length_for_sort_data更大，那么使用第二种优化之后的算法，否则使用第一种算法。

​        适当加大系统变量 max_length_for_sort_data 的值，能够让 MySQL 选择更优化的 Filesort 排序算法。当然，假如max_length_for_sort_data 设置过大，会造成CPU利用率过低和磁盘I/O过高，CUP 和 I/O平衡就足够了。

​		适当加大 sort_buffer_size 排序区，尽量让排序在内存中完成，而不是通过创建临时表存放在文件中进行；当然也不能无限制加大 sort_buffer_size 排序区，因为sort_buffer_size 参数是每个线程独占的，设置过大，会导致服务器 swap 严重，要考虑数据库活动链接数和服务器内存的大小适当设置。

​		尽量只使用必要的字段，select 具体的字段名称，而不是 select * 选择所有字段，这样可以减少排序区的使用，提高性能。



### 15.4.4 优化Group By 语句

​		默认情况下，MySQL对所有group by col1，col2,... 的字段进行排序。这在与查询中指定Order by col1,col2,.. 类似。因此，如果显示包括一个包含相同列的ORDER BY 子句，则对MySQL实际执行性能没有什么影响。

​		如果查询包括 group by 但用户想要避免排序结果的消耗，则可以指定ORDER BY NULL 禁止排序，如下面的例子：

```mysql
mysql> explain select payment_date,sum(amount) from payment group by payment_date \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: index
possible_keys: idx_payment_date
          key: idx_payment_date
      key_len: 13
          ref: NULL
         rows: 16125
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.02 sec)

mysql> explain select payment_date, sum(amount) from payment group by payment_date order by null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: index
possible_keys: idx_payment_date
          key: idx_payment_date
      key_len: 13
          ref: NULL
         rows: 16125
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```



### 15.4.5 优化 JOIN 操作

​		MySQL目前对于多表JOIN 在目前只支持一种算法——Nested-Loop Join（NLj）。NLj的原理非常简单，就是内外两层循环，对于外循环中的每条记录，都要在内循环中做一次检索，如下面的伪代码所示：

```mysql
for each row in t1 matching range{
	for each row in t2 matching reference key {
		if row satisfies join conditions,send to client
	}
}
```

​		其中t1 和 t2 表进行了JOIN，t1 通过范围扫描取每条记录作为外循环，t2 通过关联字段在表中做扫描，满足条件则返回客户端；不断重复这个过程直到外循环结束。外循环的表通常也通常称为驱动表。

​		从这个流程来看，NLJ 的性能高低主要取决于两方面：一是外循环的结果集大小，二是内循环扫描数据的效率。常见的优化方案是在驱动表上加上尽可能地where 条件并创建合适索引，使得外循环地结果集更小，读取效率更高；内循环为了提高扫描效率，通常需要在关联字段上添加索引。

​		通过上面地优化，在大多数情况下，NLJ的性能是可以满足需求的，尤其是关联字段在内循环是主键或者唯一索引时效率尤其高。但有两种情况，NLJ的性能会有比较明显地下降。

+ 外循环结果极大，导致访问内循环表地io次数非常多。
+ 内循环地关联字段并不是唯一索引，而是普通的辅助索引。如果访问地数据列不在辅助索引上，此时需要再次回表，通过辅助索引地主键找到聚集索引地实际数据，而回表会导致大量的随机io产生，导致性能下降明显。

为了优化这两个问题，MySQL先后推出了NLJ地变种BNL（Block Nested-Loop Join）和 BKA（Batched Key Access）。

#### 1. BNL

BNL在MySQL较早版本就引入，通过缓存外层循坏读地行，来降低内层表地读取次数。例如，10行数据读入到buffer中，然后buffer 被传递到内层循环，内层表读出的每一行都要跟这个缓存的10行依次做对比，这样就降低了内层表数据的读取次数。

​		在MySQL5.7中，BNL优化器特性默认是打开的，以下示例将 customer 和 payment 表进行join，关联字段均无索引：

```mysql
mysql> show variables like 'optimizer_switch' \G;
*************************** 1. row ***************************
Variable_name: optimizer_switch
        Value: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on
1 row in set, 1 warning (0.01 sec)
```

​		BNL 性能虽然大幅度提高，但是使用条件较为苛刻，只有当join类型是 all/index/range 时才可以，也就是内表不使用索引或者索引效率很低时才不得已使用。buffer的大小由参数 join_buffer_size进行设置，buffer中保存参与连接的所有列信息，join完成后buffer释放，对于使用到BNL特性且性能较差的SQL，建议在session级别将join_buffer_size 临时增大来提高性能，

#### 2.MRR & BKA

​		从上面的介绍知道，BNL的使用场景较为苛刻，最重要的条件是内表关联字段没有索引或者索引效率很低，此时使用BNL 可以较明显的降低防问内表的次数，同时降低回表的IO 次数，以此来达到优化的目的。但在大多数情况下，表的join 操作通常是通过效率较高的索引来做ref 或者 eq_ref 方式进行连接，这种情况下，BNL是无法使用的。为了优化这种更常见的join，MySQL引入了 MRR 和 BKA。

​		MRR（Multi Range Read） 是MySQL 5.6 引入的特性。MRR优化的目的就是为了减少磁盘的随机访问，InnoDB由于聚集索引的特性，如果查询使用辅助索引，并且用到表中非索引列，那么需要回表读取数据做后续处理，过于随机的回表会伴随着大量的随机IO。而MRR的优化并不是每次通过辅助索引读取到数据就回表，而是通过范围扫描将数据存入read_rnd_buffer_size ,然后对其按照 Primary Key （RowID） 排序，最后使用排序好的数据进行顺序回表，因为 InnoDB中叶子节点数据是按照 Primary Key（RowID）进行排序的，这样查询语句将带来极大的性能提升。

​		MRR特性在单表和多表join 查询中都可以使用。其中，单表通常通过范围查询（range access）；多表join方式如果是 ref/eq_ref，则先通过BKA算法批量提取key到join buffer,然后将buffer 中的key 作为参数传入 MRR的调用接口，MRR高效读取需要的数据返回。

​		如果打开MRR 特性，则需要设置以下两个优化器参数：

```mysql
set optimizer_switch='mrr=on,mrr_cost_based=off';
```

​		其中 mrr 参数控制 MRR 特性是否打开，默认 on；mrr_cost_based 控制是否根据优化器的计算成本来决定使用MRR特性，默认是on；如果希望尽可能使用MRR，可以将此参数设置为 off。

​		要查看是否使用了MRR 特性，需要观察在执行计划的 Extra 部分是否存在 “Using MRR” 字符串，下例sql就使用了 MRR：

```mysql
mysql> set optimizer_switch='mrr=on,mrr_cost_based=off';
Query OK, 0 rows affected (0.00 sec)

mysql> desc  select * from payment where customer_id between 1 and 200 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: NULL
         rows: 5444
     filtered: 100.00
        Extra: Using index condition; Using MRR
1 row in set, 1 warning (0.00 sec)
```



BKA(Batched Key Access) 是 MySQL 5.6 引入的新算法，结合MRR特性进行高效JOIN操作的，算法具体工作步骤如下。

+ 将外循环表中相关的列放入Join Buffer 中。
+ 批量的将Key（索引键值）发送到MRR接口。
+ MRR通过收到的Key，根据其对应的Primary Key（RowID）进行排序，然后在根据排序后的Primary Key(RowID)顺序的读取聚集索引，得到需要的列数据。
+ 返回结果集给客户端。

MySQL 5.7 以后，BKA默认是打开的，由优化器中的参数batched_key_access 来控制。如果要使用BKA，则需要先打开 MRR 特性，通常一起设置如下参数：

```mysql
set optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
```

判断是否使用了BKA算法，需要查看执行计划中 extra 部分是否含有 “Using join buffer(Batched Key Access)” 字符串。

通过BKA来做JOIN，很多情况下可以提高链接的效率，但对JOIN 也有一定的条件限制，一个条件是连接的列要求是唯一索引或者普通索引，但不能是主键；另一个是要有对非主键列的查询操作，否则优化器就可以通过覆盖索引等方式直接得到需要的数据，不需要回表，也就不需要用到MRR接口。



### 15.4.6 优化嵌套查询

​		MySQL 4.1 开始支持SQL的子查询。这个技术可以使用 SELECT 语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询可以被更有效率的连接（JOIN）替代。

​		在线面的例子中，要从客户表customer 中找到不在支付表 payment 中的所有客户信息：

```mysql
mysql> explain select * from customer where customer_id not in (select customer_id from payment)\G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: customer
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: Using where
*************************** 2. row ***************************
           id: 2
  select_type: DEPENDENT SUBQUERY
        table: payment
   partitions: NULL
         type: index_subquery
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: func
         rows: 26
     filtered: 100.00
        Extra: Using index
2 rows in set, 1 warning (0.01 sec)
```

​		如果使用连接（JOIN）来完成这个查询工作，速度将会快很多。尤其是当 payment 表中对 customer_id 建有索引，性能将会更好，具体查询如下：

```mysql
mysql> explain select * from customer a left join payment b on a.customer_id=b.customer_id where b.customer_id is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.a.customer_id
         rows: 26
     filtered: 100.00
        Extra: Using where; Not exists
2 rows in set, 1 warning (0.00 sec)
```

​		从执行计划中可以看出查询关联的类型从index_subquery 调整为了ref，在MySQL 5.5 以下版本（包括MySQL5.5），子查询的效率还是不如关联查询（JOIN）。

​		连接之所以更有效率一些，是因为MySQL 不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。

### 15.4.7 MySQL如何优化 OR 条件

​		对于含有 OR 的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引；如果没有索引，则应该考虑增加索引。

> 结论：
>
> 1. 在两个独立索引上面做 OR 操作，可以正确的用到索引，MySQL在处理含有 OR 字句的查询时，实际是对OR的各个字段分别查询后的结果进行 UNION 操作。
>
> 2. 当在建有复合索引的列上做OR 操作时，不能用到索引。



### 15.4.8 优化分页查询

​		一般分页查询时，通过创建覆盖索引能够比较好的提高性能。一个常见的又非常头痛的分页场景是“limit 1000，20”，此时MySQL 排序前1020 条记录后仅仅需要返回第1001到1020条记录，前1000条记录会被丢弃，查询和排序的代价非常高。

#### 1. 第一种优化思路

​		在索引上完成排序分页的操作，最后根据主键关联回原表查询所需要的其它列内容。例如，对电影表 film 根据 标题 title 排序后读取某一页数据，直接查询的时候，能够从explain 的输出结果中看到优化器实际上做了全表扫描，处理效率不高：

```mysql
mysql> explain select film_id, description from film order by title limit 50,5 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: Using filesort
1 row in set, 1 warning (0.03 sec)
```

​		而按照索引分页后回表方式改写SQL 后，从 explain 的输出结果中已经看不到全表扫描了：

```mysql
mysql> explain select a.film_id,a.description from film a inner join (select film_id from film order by title limit 50,5) b on a.film_id=b.film_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: PRIMARY
        table: <derived2>
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 55
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: PRIMARY
        table: a
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: b.film_id
         rows: 1
     filtered: 100.00
        Extra: NULL
*************************** 3. row ***************************
           id: 2
  select_type: DERIVED
        table: film
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_title
      key_len: 514
          ref: NULL
         rows: 55
     filtered: 100.00
        Extra: Using index
3 rows in set, 1 warning (0.00 sec)
```

​		这种方式让MySQL扫描尽可能少的页面来提高分页效率。

#### 2. 第二种优化思路

​		把 LIMIT 查询转换成某个位置的查询，例如，假设每页10条记录，查询支付表payment 中按照租赁标号 rental_id 逆序排序的第 42 页记录，能够看到执行计划走了全表扫描：

```mysql
mysql> explain select * from payment order by rental_id desc limit 410,10 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 16125
     filtered: 100.00
        Extra: Using filesort
1 row in set, 1 warning (0.00 sec)
```

​		和开发人员协商一下，翻页的过程中通过增加一个参数 last_page_record,用来记录上一页最后一行的租赁编号 rental_id,例如第41页最后一行的租赁编号 rental_id=15640;

```mysql
mysql> select * from payment order by rental_id desc limit 400,10 ;
+------------+-------------+----------+-----------+--------+---------------------+---------------------+
| payment_id | customer_id | staff_id | rental_id | amount | payment_date        | last_update         |
+------------+-------------+----------+-----------+--------+---------------------+---------------------+
|       1669 |          60 |        1 |     15649 |   2.99 | 2005-08-23 08:28:03 | 2006-02-15 22:12:45 |
|       2193 |          80 |        1 |     15648 |   8.99 | 2005-08-23 08:27:57 | 2006-02-15 22:12:52 |
|       6785 |         251 |        2 |     15647 |   2.99 | 2005-08-23 08:23:56 | 2006-02-15 22:14:50 |
|       3088 |         114 |        2 |     15646 |   3.99 | 2005-08-23 08:19:55 | 2006-02-15 22:13:07 |
|       5831 |         214 |        2 |     15645 |   2.99 | 2006-02-14 15:16:03 | 2006-02-15 22:14:15 |
|       1201 |          43 |        2 |     15644 |   3.98 | 2006-02-14 15:16:03 | 2006-02-15 22:12:39 |
|       8105 |         298 |        1 |     15643 |   4.99 | 2005-08-23 08:13:26 | 2006-02-15 22:15:41 |
|       4369 |         160 |        2 |     15642 |   2.99 | 2005-08-23 08:09:11 | 2006-02-15 22:13:36 |
|       6499 |         240 |        2 |     15641 |   0.99 | 2005-08-23 08:06:49 | 2006-02-15 22:14:41 |
|       7095 |         262 |        1 |     15640 |   4.99 | 2005-08-23 08:04:40 | 2006-02-15 22:15:01 |
+------------+-------------+----------+-----------+--------+---------------------+---------------------+
```

​		那么在翻页到第42页时，可以根据第41页最后一条记录向后追溯，相应的SQL可以改成：

```mysql
mysql> explain select * from payment where rental_id < 15640 order by rental_id desc limit 10 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: fk_payment_rental
          key: fk_payment_rental
      key_len: 5
          ref: NULL
         rows: 8062
     filtered: 100.00
        Extra: Using index condition; Backward index scan
1 row in set, 1 warning (0.00 sec)
```

> 注意：这样把limit m,n 转换成 limit n 的查询，只适合在排序字段不会出现重复值的特定环境，能够减轻分页翻页的压力；如果排序字段出现大量重复值，而仍进行这种优化，那么分页结果可能会丢失部分记录。

### 15.4.9 使用SQL提示

​		SQL 提示（SQL HINT）是优化数据库的一个重要手段，简单来说就是在SQL 语句中加入一些人为的提示来达到优化操作的目的。下面是一个使用SQL提示的示例：

```mysql
select sql_buffer_results * from ...
```

​		这个语句将强制MySQL生成一个临时结果集。只要临时结果集生成后，所有表上的锁定均被释放。这能在遇到表锁定问题时要花很长时间将结果传给客户端时有所帮助，因为可以尽快释放锁资源。

​		下面是一些在MySQL中常用的SQL 提示。

#### 1.USE INDEX

​		在查询语句中表名的后面，添加USE INDEX 来提供希望MySQL 去参考的索引列表，就可以让MySQL 不再考虑其他可用的索引。

```mysql
mysql> explain select count(*) from rental use index(idx_rental_date) \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_rental_date
      key_len: 10
          ref: NULL
         rows: 16008
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.05 sec)
```

#### 2.IGNORE INDEX

​		如果用户只是单纯地想让MySQL忽略一个或者多个索引，则可以使用 IGNORE INDEX 作为 HINT。同样是上面地例子，这次来看一下查询过程忽略索引idx_rental_date 地情况：

```mysql
mysql> explain select count(*) from rental ignore index(idx_rental_date) \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_fk_staff_id
      key_len: 1
          ref: NULL
         rows: 16008
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

​		从执行计划可以看出，系统忽略地指定的索引，使用了索引 idx_fk_staff_id。

#### 3.FORCE INDEX

​		为强制 MySQL使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 HINT。例如，当不强制使用索引的时候，因为大部分库存 inventory_id 的值都是大于1的，因此MySQL会默认进行全表扫描，而不使用索引，如下所示：

```mysql
mysql> explain select * from rental where inventory_id > 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ALL
possible_keys: idx_fk_inventory_id
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 16008
     filtered: 50.00
        Extra: Using where
1 row in set, 1 warning (0.01 sec)
```

​		尝试使用 use index 的 hint 看看：

```mysql
mysql> explain select * from rental use index(idx_fk_inventory_id) where inventory_id  > 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ALL
possible_keys: idx_fk_inventory_id
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 16008
     filtered: 50.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		发现仍然不行，MySQL 还是选择走全表扫描。但是，当使用 FORCE INDEX 进行提示时，即便使用索引的效率不是最高，MySQL还是选择使用了索引，这是MySQL留给用户的一个自行选择执行计划的权利。加入FORCE INDEX提示后再次执行以上SQL 语句：

```mysql
mysql> explain select * from rental force index (idx_fk_inventory_id) where inventory_id > 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: range
possible_keys: idx_fk_inventory_id
          key: idx_fk_inventory_id
      key_len: 3
          ref: NULL
         rows: 8004
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

​		果然，执行计划中使用了FORCE INDEX 后的索引。



## 15.5 直方图

​		直方图是MySQL 8.0引入的新功能。利用直方图，用户可以对一张表的一列做数据分布的统计，特别是针对没有索引的字段。这可以帮助优化器找到更优的执行计划。统计直方图的主要使用场景是用来计算字段选择性，即过滤效率。

### 15.5.1 什么是直方图

​		在数据库中，查询优化器负责将SQL 转换成最有效的执行计划。但有时，由于一些字段的数据分布不均衡，导致优化器针对某些值不会选择最优的执行计划，从而使得执行效率降低。为了能做出更准确的选择，优化器需要了解条件列中具体的数据分布情况，而直方图的引入就是为了统计这些信息。

​		直方图的主要操作命令有以下两个。

+ 生成直方图：

  ```mysql
  ANALYZE TABLE tbl_name UPDATE HISTOGRAM ON col_name [, col_name] WITH N BUCKETS;
  ```

+ 删除直方图：

  ```mysql
  ANALYZE TABLE tbl_name DROP HISTOGRAM ON col_name [, col_name];
  ```

​	

​		其中，BUCKETS 表示生成桶的个数，桶用来存放列中不同值的分布情况，默认值为100，最大到1024。

​		举一个简单例子，员工表emp1 的性别字段 gender 数据分布如下：

```mysql
mysql> select gender,count(1) from emp1 group by gender;
+--------+----------+
| gender | count(1) |
+--------+----------+
| M      |      198 |
| F      |       99 |
+--------+----------+
2 rows in set (0.00 sec)
```

​		如果没有直方图，查询gender为‘M’ 或者 'F' ,执行计划：

```mysql
mysql> desc select * from emp1 where gender='M' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: emp1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 297
     filtered: 50.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		可以发现，执行计划中的filtered 值都是50%，及优化器不知道数据实际分布情况，只是按照值得个数进行平均分配的，在gender上创建直方图，则执行计划会按照实际的数据分布进行过滤，如下所示：

```mysql
mysql> analyze table emp1 update histogram on gender \G;
*************************** 1. row ***************************
   Table: sakila.emp1
      Op: histogram
Msg_type: status
Msg_text: Histogram statistics created for column 'gender'.
1 row in set (0.01 sec)

mysql> desc select * from emp1 where gender='F' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: emp1
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 297
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		上面的 analyze 命令在 emp1 的gender字段上创建了直方图，后面的执行计划显示 filtered 属性已经从50%改为0.33%，符合实际分布情况。这个信息使得优化器对gender 字段查询的代价计算更为精确，从而在某些gender 查询相关的sql中生成更为高效的执行计划。



### 15.5.2 直方图得分类

​		MySQL目前支持两种直方图类型，等宽直方图（singleton）和 等高直方图（equi-height）。它们得共同点是，都将数据分到了一系列得buckets 中；区别在于如果列中不同值的个数小于等于bucket数，则为等宽直方图；反之则为等高直方图。MySQL会自动将数据划到不同得bucket中，也会自动决定创建那种类型的直方图。

​		直方图得统计信息存放在 information_schema 库的column_statistics 视图中，以json格式保存。上例中 gender 列的直方图信息内容如下：

```mysql
mysql> select * from information_schema.column_statistics \G;
*************************** 1. row ***************************
SCHEMA_NAME: sakila
 TABLE_NAME: emp1
COLUMN_NAME: gender
  HISTOGRAM: {"buckets": [["base64:type254:Rg==", 0.3333333333333333], ["base64:type254:TQ==", 1.0]], "data-type": "string", "null-values": 0.0, "collation-id": 33, "last-updated": "2020-11-07 01:39:14.381016", "sampling-rate": 1.0, "histogram-type": "singleton", "number-of-buckets-specified": 100}
1 row in set (0.00 sec)
```

​		其中，HISTOGRAM列记录了 gender 字段的直方图信息，内容包括如下几项：

+ buckets: [["base64:type254:Rg==", 0.3333333333333333], ["base64:type254:TQ==", 1.0]] 表示 gender 上创建了两个bucket，bucket为1的值包含了33.33%的数据，bucket为2 的值包含了 1- 33.33% 的数据，即2后面的1.0 是个累积的数据分布。由于enum 保存的并不是字面值，这里的1和2是String类型的“M” 和“F” 实际保存的值。
+ data-type:"string" 表示gender字段是枚举类型。
+ null-values：0.0 表示gender列中没有空值。
+ collation-id:33 表示排序方式，对应 information_schema 下 collations 中的id字段。
+ last-updated：表示直方图的最后更新日期。直方图只能手工 update，而不会随着数据的更新而更新；当数据量发生大的变更时，要重新生成新的直方图。
+ sampling-rate：1.0 表示数据的采样率，对于数据量巨大的表，MySQL出于性能考虑，不会全部扫描，只会采样部分数据来生成直方图。采样大小由参数 histogram_generation_max_mem_size 进行控制，这个值是控制最大多少内存能允许被使用。
+ histogram-type:生成直方图类型，singleton 表示等宽直方图，equi-height 表示等高直方图。
+ number-of-buckets-specified:表示制定了多少个bucket，对于等宽直方图来说，如果创建直方图时指定的 buckets 的个数大于列中唯一值的个数，则实际只需要创建唯一值的个数的buckets就可以了。本例中的100，而实际创建的bucket是两个。



​		对于等高直方图，bucket的显示内容有所不同，由于列中不同值的个数大于bucket的数量，因此每个bucket上对应的不是一个值，而是一个具有上下限的列值范围。



## 15.6 使用查询重写

​		使用过Oracle 数据库的同学可能知道，如果某个SQL的执行计划出了问题，可以使用sql_profile,在不修改SQL本身的情况下，为SQL绑定更好的执行计划，这样做的好处是可以不依赖于代码的调整，第一时间解决因为执行计划选择错误而带来的问题。

​		而MySQL一直以来，都缺少能够便捷地干预执行计划的方式，经常需要通过修改SQL地写法或者调整索引地方式来达到改变执行计划地目的，而修改索引的方式，代价往往也比较大，而且无法保证修改索引后执行计划就能够符合预期，这是DBA 在面对 MySQL中的SQL 优化时经常会遇到地一个问题。

​		在MySQL5.7中，提供了Query Rewrite Plugin，可以通过规则匹配的方式，将符合条件的SQL进行重写，从而达到调整执行计划或者其他地目标。下面来测试一下这个插件的安装和使用方法。

​		在$mysqlhome/share 目录下执行安装脚本，创建 query_rewrite 数据库和rewrite_rules 规则表：

```mysql
D:\work\databases\mysql8.0.16\mysql-8.0.16-winx64\share>mysql -uroot -p < install_rewriter.sql
Enter password: ************

mysql> show databases like 'query%';
+-------------------+
| Database (query%) |
+-------------------+
| query_rewrite     |
+-------------------+
1 row in set (0.00 sec)

mysql> use query_rewrite;
Database changed
mysql> show tables;
+-------------------------+
| Tables_in_query_rewrite |
+-------------------------+
| rewrite_rules           |
+-------------------------+
1 row in set (0.00 sec)

mysql> show global variables like 'rewriter_enabled';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| rewriter_enabled | ON    |
+------------------+-------+
1 row in set, 1 warning (0.01 sec)
```

​		通过上面的查询，可以看到SQL重写插件已经打开。需要注意的是，SQL重写插件安装之后，即使关闭插件，仍然会有一定地额外开销，考虑到SQL重写插件可以动态安装和打开，因此，如果不是确定要使用这一插件，没有必要提前安装。

​		下面通过一个示例来演示一下查询重写是如何发挥作用的。

​		（1）增加匹配规则，将“select ？” 全部重写为  “select ？+1” ，其中 “？” 是通配符，用来匹配数据值：

```mysql
mysql> insert into query_rewrite.rewrite_rules(pattern, replacement) values ('select ?', 'select ?+1');
Query OK, 1 row affected (0.01 sec)
```

​		（2）刷新使规则生效：

```mysql
mysql> call query_rewrite.flush_rewrite_rules();
Query OK, 1 row affected (0.01 sec)
```

​		（3）看一下重新地效果：

```mysql
mysql> select 1;
+-----+
| 1+1 |
+-----+
|   2 |
+-----+
1 row in set, 1 warning (0.00 sec)

mysql> show warnings;
+-------+------+----------------------------------------------------------------------+
| Level | Code | Message                                                              |
+-------+------+----------------------------------------------------------------------+
| Note  | 1105 | Query 'select 1' rewritten to 'select 1+1' by a query rewrite plugin |
+-------+------+----------------------------------------------------------------------+
1 row in set (0.00 sec)
```

​		可以看到 select 1 被重写为 select 1 + 1，同时MySQL也返回了一个warning，提示原来的SQL被重写了。需要注意的是，改写对函数无效：

```mysql
mysql> select pi();
+----------+
| pi()     |
+----------+
| 3.141593 |
+----------+
1 row in set (0.00 sec)
```

​		接下来，再给出一个示例，来说明如何通过查询重写来优化执行计划：

```mysql
mysql> create table tab_test_rewrite(order_id varchar(20) not null,user_id varchar(40) not null,status smallint(5) not null, primary key (order_id), key idx_user_id (user_id), key idx_status (status));
Query OK, 0 rows affected (0.08 sec)
```

​		假设这是一个订单表，其中保存了订单id、用户id和订单状态，导入数据后，总共有100个用户，每个用户有1000个订单，并且这些订单的状态都是正常，用 status=1来表示，最后再加入1条状态为0的数据，表示异常。

```mysql
mysql> delimiter //
mysql> create procedure p_test1()
begin
declare v_user int;
declare v_order int;
set @v_user=1;
while @v_user < 101
do
set @v_order = 1;
while @v_order < 1001
do
insert into tab_test_rewrite (order_id,user_id,status) values (concat('order_',@v_user,'_',@v_order), concat('user_',@v_user), 1);
set @v_order=@v_order+1;
end while;
set @v_user = @v_user + 1;
end while;
insert into tab_test_rewrite (order_id, user_id,status) values ('order_1_1001', 'user_1', 0);
end //
Query OK, 0 rows affected (0.01 sec)

mysql> delimiter ;
mysql> call p_test1();
Query OK, 1 row affected (11 min 29.44 sec)
```

​		现在要查询某个用户的状态为1的数据，首先来看一下默认的执行计划：

```mysql
mysql> explain select * from tab_test_rewrite where user_id='user_1' and status =1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tab_test_rewrite
   partitions: NULL
         type: index_merge
possible_keys: idx_user_id,idx_status
          key: idx_user_id,idx_status
      key_len: 122,2
          ref: NULL
         rows: 500
     filtered: 100.00
        Extra: Using intersect(idx_user_id,idx_status); Using where; Using index
1 row in set, 1 warning (0.00 sec)
```

​		可以看到，默认的执行计划是扫描了idx_user_id 和 idx_status 两个索引，并做了 index_merge,而实际上，绝大多数记录的status都等于1，所以idx_status 对于状态是1的数据的选择度很差，一般没有必要去扫描这个索引，再来看一下如果使用 force index 之后的执行计划：

```mysql
mysql> explain select * from tab_test_rewrite force index(idx_user_id) where user_id='user_1' and status = 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: tab_test_rewrite
   partitions: NULL
         type: ref
possible_keys: idx_user_id
          key: idx_user_id
      key_len: 122
          ref: const
         rows: 1001
     filtered: 10.80
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		这个执行计划更加符合我们的预期，为了优化这个查询，下面对这个查询进行改写：

```mysql
mysql>  insert into query_rewrite.rewrite_rules(pattern_database,pattern, replacement) values 
    ->   ('query_rewrite' ,'select * from tab_test_rewrite where user_id = ? and status = 1','select * from tab_test_rewrite force index(idx_user_id) where user_id = ? and status = 1');
Query OK, 1 row affected (0.01 sec)

mysql> call query_rewrite.flush_rewrite_rules();
Query OK, 1 row affected (0.01 sec)
```

​		重新执行以下查询：

```mysql
mysql> select * from tab_test_rewrite where user_id='user_1' and status=1;
....
mysql> show warnings \G;
*************************** 1. row ***************************
  Level: Note
   Code: 1105
Message: Query 'select * from tab_test_rewrite where user_id='user_1' and status=1' rewritten to 'select * from tab_test_rewrite force index(idx_user_id) where user_id = 'user_1' and status = 1' by a query rewrite plugin
1 row in set (0.00 sec)
```

​		可以看到，查询已经正确被改写。

​		当然，MySQL对于查询改写的处理相比 Oracle 来说仍然比较简单，而这种通过字符串匹配和替换的方式来做的改写，也存在一些问题，例如，可能造成一些查询被错误的修改。



## 15.7 常用SQL技巧

### 15.7.1 正则表达式的使用

​		MySQL 利用RegExp 命令提供给用户扩展的正则表达式功能，RegExp 实现的功能类似UNIX上GREP和SED的功能，并且RegExp在进行模式匹配时是区分大小写的。熟悉并掌握RegExp的功能可以使模式匹配工作事半功倍。

​		MySQL 5.7 中可以使用的模式序列如下：

| 序列   | 序列说明                     |
| ------ | ---------------------------- |
| ^      | 在字符串的开始处进行匹配     |
| $      | 在字符串的末尾处进行匹配     |
| .      | 匹配任意单个字符，包括换行符 |
| [...]  | 匹配出括号内的任意字符       |
| [^...] | 匹配出不在括号内的任意字符   |
| a*     | 匹配零个或多个a(包括空串)    |
| a+     | 匹配一个或多个a(不包括空串)  |
| a?     | 匹配一个或零个a              |
| a1\|a2 | 匹配a1或a2                   |
| a(m)   | 匹配m个a                     |
| a(m,)  | 匹配m个a或更多a              |
| a(m,n) | 匹配m到n个a                  |
| a(,n)  | 匹配0到n个a                  |
| (...)  | 将模式元素组成单一元素       |

​		下面举一些例子来介绍常用正则表达式的使用方法。

+ “^” 在字符串的开始处进行匹配，返回结果为1表示匹配，返回结果为0表示不匹配。下例中尝试匹配字符串“abcdefg” 是否以字符“a”开始。

  ```mysql
  mysql> select 'abcdefg' regexp '^a';
  +-----------------------+
  | 'abcdefg' regexp '^a' |
  +-----------------------+
  |                     1 |
  +-----------------------+
  1 row in set (0.02 sec)
  ```

+ "$" 在字符串的末尾处进行匹配。下例中尝试匹配字符串“abcdefg”是否以字符串“g”结束。

  ```mysql
  mysql> select 'abcdefg' regexp 'g$';
  +-----------------------+
  | 'abcdefg' regexp 'g$' |
  +-----------------------+
  |                     1 |
  +-----------------------+
  1 row in set (0.00 sec)
  ```

+ "." 匹配任意单个字符串，包括换行符。下例中字符串“abcdefg” 尝试匹配单字符“h” 和 “f”。

  ```mysql
  mysql> select 'abcdefg' regexp '.h', 'abcdefg' regexp '.f';
  +-----------------------+-----------------------+
  | 'abcdefg' regexp '.h' | 'abcdefg' regexp '.f' |
  +-----------------------+-----------------------+
  |                     0 |                     1 |
  +-----------------------+-----------------------+
  ```

+ "[...]" 匹配出括号内的任意字符。下例中字符串 “abcdefg” 尝试匹配 “fhk”中的任意一个字符，如果有一个字符能匹配上，则返回1。

  ```mysql
  mysql> select  'abcdefg' regexp '[fhk]';
  +--------------------------+
  | 'abcdefg' regexp '[fhk]' |
  +--------------------------+
  |                        1 |
  +--------------------------+
  ```

+ "\[^...]" 匹配不包括括号内的任意字符。和“[...]” 刚好相反。下例中字符串“efg” 和 “X” 中如果有一个字符匹配不上 “\[^XYZ]” 中的任意一个字符，则返回1；如果匹配上，则返回0.

  ```mysql
  mysql> select 'efg' regexp '[^XYZ]', 'X' regexp '[^XYZ]';
  +-----------------------+---------------------+
  | 'efg' regexp '[^XYZ]' | 'X' regexp '[^XYZ]' |
  +-----------------------+---------------------+
  |                     1 |                   0 |
  +-----------------------+---------------------+
  ```



### 15.7.2 巧用RAND() 提取随即行

​		大多数数据库都会提供产生随机数的包或者函数，通过这些包或者函数可以产生用户需要的随机数，也可以用来从数据表中抽取随机产生的记录，这对一些抽样分析统计是非常有用的。例如Oracle中用DBMS_RANDOM 包产生随机数，而在MySQL中，产生随机数的方法是RAND() 函数。可以利用这个函数与ORDER BY 子句一起完成随机抽取某些行的功能。它的原理其实就是 ORDER BY RAND() 能够把数据随机排序。

​		例如，可按照随机检索数据行：

```mysql
mysql> select * from category order by rand();
+-------------+-------------+---------------------+
| category_id | name        | last_update         |
+-------------+-------------+---------------------+
|          15 | Sports      | 2006-02-15 04:46:27 |
|          14 | Sci-Fi      | 2006-02-15 04:46:27 |
|          13 | New         | 2006-02-15 04:46:27 |
|           1 | Action      | 2006-02-15 04:46:27 |
|           7 | Drama       | 2006-02-15 04:46:27 |
|           2 | Animation   | 2006-02-15 04:46:27 |
|           5 | Comedy      | 2006-02-15 04:46:27 |
|          12 | Music       | 2006-02-15 04:46:27 |
|           8 | Family      | 2006-02-15 04:46:27 |
|          10 | Games       | 2006-02-15 04:46:27 |
|           3 | Children    | 2006-02-15 04:46:27 |
|           9 | Foreign     | 2006-02-15 04:46:27 |
|           6 | Documentary | 2006-02-15 04:46:27 |
|          11 | Horror      | 2006-02-15 04:46:27 |
|           4 | Classics    | 2006-02-15 04:46:27 |
|          16 | Travel      | 2006-02-15 04:46:27 |
+-------------+-------------+---------------------+
```

​		这样，如果想随机抽取一部分样本的时候，把数据随机排序后再抽取前n条记录就可以了，比如：

```mysql
mysql> select * from category order by rand() limit 5;
+-------------+-------------+---------------------+
| category_id | name        | last_update         |
+-------------+-------------+---------------------+
|           5 | Comedy      | 2006-02-15 04:46:27 |
|           3 | Children    | 2006-02-15 04:46:27 |
|           6 | Documentary | 2006-02-15 04:46:27 |
|          10 | Games       | 2006-02-15 04:46:27 |
|          11 | Horror      | 2006-02-15 04:46:27 |
+-------------+-------------+---------------------+
```

​		上面的例子从类别表category中随机抽取了 5 个样本，随机抽取样本对总体的统计具有十分重要的意义，因此这个函数非常有用。



### 15.7.3 利用GROUP BY的 WITH ROLLUP 子句

​		在SQL语句中，使用GROUP BY的 with rollup 字句可以检索出更多的分组聚合信息，它不仅仅能像一般的 GROUP BY 语句那样检索出各组的聚合信息，还能检索出本组类的整体聚合信息，具体如下所示。

​		在支付表 payment 中，按照支付时间 payment_date 的年月、经手员工编号 staff_id 列分组对支付金额 amount 列进行聚合计算如下：

```mysql
mysql> select date_format(payment_date, '%y-%m'), staff_id, sum(amount) from payment group by date_format(payment_date, '%y-%m'),staff_id;
+------------------------------------+----------+-------------+
| date_format(payment_date, '%y-%m') | staff_id | sum(amount) |
+------------------------------------+----------+-------------+
| 05-05                              |        1 |     2621.83 |
| 05-06                              |        1 |     4776.36 |
| 05-06                              |        2 |     4855.52 |
| 05-07                              |        2 |    14370.35 |
| 05-07                              |        1 |    14003.54 |
| 05-08                              |        2 |    12218.48 |
| 05-08                              |        1 |    11853.65 |
| 06-02                              |        2 |      280.09 |
| 05-05                              |        2 |     2202.60 |
| 06-02                              |        1 |      234.09 |
+------------------------------------+----------+-------------+
10 rows in set (0.03 sec)

mysql> select date_format(payment_date, '%y-%m'), staff_id, sum(amount) from payment group by date_format(payment_date, '%y-%m'),staff_id with rollup;
+------------------------------------+----------+-------------+
| date_format(payment_date, '%y-%m') | staff_id | sum(amount) |
+------------------------------------+----------+-------------+
| 05-05                              |        1 |     2621.83 |
| 05-05                              |        2 |     2202.60 |
| 05-05                              |     NULL |     4824.43 |
| 05-06                              |        1 |     4776.36 |
| 05-06                              |        2 |     4855.52 |
| 05-06                              |     NULL |     9631.88 |
| 05-07                              |        1 |    14003.54 |
| 05-07                              |        2 |    14370.35 |
| 05-07                              |     NULL |    28373.89 |
| 05-08                              |        1 |    11853.65 |
| 05-08                              |        2 |    12218.48 |
| 05-08                              |     NULL |    24072.13 |
| 06-02                              |        1 |      234.09 |
| 06-02                              |        2 |      280.09 |
| 06-02                              |     NULL |      514.18 |
| NULL                               |     NULL |    67416.51 |
+------------------------------------+----------+-------------+
16 rows in set (0.03 sec)
```

​		从上面的例子中可以看到，第二个SQL语句的结果比第一个SQL语句的结果多出了很多行，而这些行反映出了更多的信息。例如，第二个SQL语句的结果的前两行表示 2005-05 月份各个员工（1，2）的经手的支付金额，而第三行表示2005-05 月总支付金额，这个信息在第一个SQL语句中是不能反应出来的，第16行表示总支付金额，这个信息在第一个SQL中是没有的。

​		其实 WITH ROLLUP 反映的是一种 OLAP思想，也就是说这一个GROUP BY语句执行完成后可以满足用户想要得到的任何一个分组以及分组组合的聚合信息值。

> 注意：当使用ROLLUP时，不能同时使用ORDER BY 子句进行结果排序。换言之，ROLLUP 和 ORDER BY是相互排斥的。此外，LIMIT用在ROLLUP后面



### 15.7.4 用BIT GROUP FUNCTIONS 做统计

​		本节主要介绍如何共同使用 GROUP BY 语句和BIT_AND,BIT_OR 函数完成统计工作。这两个函数的一般用途就是做数值之间的逻辑位运算，但是，当把它们与GROUP BY子句联合使用的时候就可以做一些其他的任务。

​		假设现在有这样一个任务：一个超市需要记录每个用户每次来超市都购买了那些商品。为了将问题简化，假设该超市只有面包、牛奶、饼干、啤酒 4种商品。那么通常该怎么做呢？一般先建立一个购物单表。里面记录购物发生的时间、顾客信息等；然后在建立一个购物单明细表，里面记录该顾客所购买的商品。这样设计表结构的优点是顾客所购买的商品的详细信息可以记录下来，比如数量、单价等，但是如果目前的这个任务只需要知道用户购买商品的种类和每次购物总价等信息，那么这种数据库结构就显得太复杂了。一般还可能会想到用一个表实现这个功能，并且用一个字段以字符串的形式记录顾客所购买的所有商品号，这也是一种方法，但是如果顾客一次购买商品比较多，需要很大的存储空间，而且将来做各种统计的时候也会捉襟见肘。

​		下面给出一种新的解决办法，类似于上面讲到的第二种方案，仍然用一个字段表示顾客购买商品的信息，但是这个字段是数值类型的而不是字符类型，该字段存储一个十进制数字，当他转换成二进制的时候，那么每一位代表一种商品，而且如果所在位是“1” 那么表示顾客购买了该商品，“0”表示没有购买该商品，比如数值的第一位代表面包（规定从右向左开始计算）、第二位代表牛奶、第三位代表饼干】第四位代表啤酒，这样如果一个用户购物清单的商品列的数值为5，那么二进制表示位0101，这样从右向左第一位和第三位是1，那么就可以知道这个用户购买了面包和饼干，而如果这个客户有多个这样的购物单（在数据库中就是有多条记录），把这些购物单按用户分组做BIT_OR() 操作就可以知道这个用户购买过什么商品。

​		下面举例说明一下这个操作，首先初始化一组数据：

```mysql
mysql> create table order_rab(id int, customer_id int, kind int);
Query OK, 0 rows affected (0.02 sec)

mysql> insert into order_rab values (1,1,5),(2,1,4);
Query OK, 2 rows affected (0.01 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> insert into order_rab values (3,2,3),(4,2,4);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select * from order_rab;
+------+-------------+------+
| id   | customer_id | kind |
+------+-------------+------+
|    1 |           1 |    5 |
|    2 |           1 |    4 |
|    3 |           2 |    3 |
|    4 |           2 |    4 |
+------+-------------+------+
4 rows in set (0.00 sec)
```

​		其中 customerid 是顾客编号，kind 是所购买的商品，初始化了两个顾客1和2的数据，他们每人购物两次，前者购买的商品数值是5和4，转化为二进制是 0101 和 0100，表示这个顾客第一次购买了牛奶和啤酒，第二次购买了牛奶；后者购买的商品数值是3和4，转化为二进制分别为 0011 和 0100，表示这个顾客第一次购买了饼干和啤酒，第二次购买了牛奶。

​		下面用BIT_OR() 函数 与 GROUP BY 子句联合起来，统计一下这两个顾客在这个超市一共都购买过什么商品，如下例：

```mysql
mysql> select customer_id,bit_or(kind) from order_rab group by customer_id;
+-------------+--------------+
| customer_id | bit_or(kind) |
+-------------+--------------+
|           1 |            5 |
|           2 |            7 |
+-------------+--------------+
2 rows in set (0.00 sec)
```

​		可以看到顾客1的BIT_OR() 结果是 5 即 0101，表示这个顾客在本超市购买过牛奶和啤酒；顾客2的BIT_OR() 结果是7 即 0111，表示这个顾客在本超市购买过牛奶、饼干、啤酒。

​		下面解释一下数据库在处理这个逻辑时的计算过程，以第一个顾客举例，BIT_OR(kind) 就相当于把kind的各个值做了一个 “或” 操作，最终结果是十进制的5.逻辑计算公司如下：

```mysql
	0101
or
	0100
=	0101
```

​		同理，可以利用BIT_AND() 统计每个顾客每次来本超市都会购买的商品，具体如下：

```mysql
mysql> select customer_id, bit_and(kind) from order_rab group by customer_id;
+-------------+---------------+
| customer_id | bit_and(kind) |
+-------------+---------------+
|           1 |             4 |
|           2 |             0 |
+-------------+---------------+
2 rows in set (0.00 sec)
```

​		顾客1的BIT_AND() 结果是4，即0100，表示顾客1每次来本超市都会购买牛奶；顾客2的BIT_AND() 结果是0，即0000 表示顾客2每次来本超市都会购买的商品。

```mysql
0101
and
0100
=
0100
```

​		从上面的例子可以看出，这种数据结构设计的好处就是能用很简洁的数据表示很丰富的信息，这种方法大大的节省存储空间，而且能够提高部分统计计算的速度。不过需要注意的是，这种设计其实损失了顾客购买商品的详细信息，比如购买的数量、当时单价、是否有折扣、是否有促销等，因此还要根据应用的实际情况有选择地考虑数据库地结构设计。



### 15.7.5 数据库名、表名大小写问题

​		在MySQL中，数据库对应操作系统下的数据目录。数据库中每个表至少对应数据库目录中地一个文件（也可能是多个，这取决于存储引擎）。因此所使用操作系统的大小写敏感性导致了数据库名的大小写敏感性。在大多数UNIX环境中，由于操作系统对大小写的敏感性导致了数据库名和表名对大小写敏感性，而在Windows中，由于操作系统本身对大小写不敏感，因此在Windows下地MySQL数据库名和表名对大小写也不敏感。

​		列、索引、存储子程序和触发器名再任何平台上对大小写不敏感。默认情况下，表别名在 UNIX中对大小写敏感，但在 Windows和maxOS X中对大小写不敏感。下面的查询在 UNIX 中会报错，因为它同时引用了别名a和A：

```mysql
select id from order_rab a where A.id=1
```

​		然而，该查询在Windows中是可以的。要想避免出现差别，最好采用一致的转换，例如总是用小写创建并引用数据库名和表名。

​		在MySQL中，如何在硬盘上保存、使用表名和数据库名是由 lower_case_tables_name 系统变量决定的，用户可以在启动MySQL服务时设置这个系统变量。lower_case_tables_name 可以采用如下的任意一个值：

| 值   | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| 0    | 使用CREATE TABLE 或 CREATE DATABASE 语句指定大写和小写在硬盘上保存表明和数据库名。名称对大小写敏感。在unix系统中的默认设置就是这个值 |
| 1    | 表名在硬盘上以小写保存，名称对大小写敏感。MySQL将所有表名转换为小写以便存储和查找。该值为Windows和mac OS X系统中的默认值 |
| 2    | 表名和数据库名在硬盘上使用CREATE TABLE 或 CREATE DATABASE 语句指定的大小写进行保存，但MySQL将他们转换为小写以便查找。此值只在对大小写不敏感的文件系统上适用 |

​		如果只在一个平台上使用MySQL，通常不需要更改lower_case_tables_name 变量。然而，如果用户想要在对大小写敏感性不同的文件系统的平台之间转移，就会遇到困难。例如，在UNIX 中，my_tables 和 My_tables 是两张不同的表，但在 Windows中，这两个表名相同。

​		在 unix 中使用 lower_case_tables_name = 0,而在windows 中使用 lower_case_tables_name = 2,这样就可以保留数据库名和表名的大小写。不利之处就是必须确保在windwos中的所有sql语句总是正确的使用大小写来引用数据库名和表名，如果SQL语句中没有正确引用数据库名和表名的大小写，那么虽然在Windows中能正确执行，但是如果将查询转移到UNIX 中，大小写不正确，将会导致查询失败。

> 注意：在UNIX中将 lower_case_tables_name 设置成1并且重启MySQL之前，必须先将旧的数据库名和表名转换为小写。尽管在某些平台中数据库名和表名对大小写不敏感，但最好养成同一查询中使用相同的大小写来引用给定的数据库名或表名的习惯。



### 15.7.6 使用外键需要注意的问题

​		在MySQL中，innodb存储引擎支持对外部关键字约束条件的检查。而对于起他类型的存储引擎的表，当使用PEFERENCES tbl_name(col_name) 子句定义列时可以使用外部关键字，但是该子句没有实际的效果，只作为备忘录或注释来提醒用户目前正定义的列指向另一个表中的一个列。

​		例如，下面的myisam 表外键就没有起作用。

```MYSQL
mysql> create table users(id int,name varchar(10), primary key (id)) engine=myisam;
Query OK, 0 rows affected (0.01 sec)

mysql> create table books (id int, bookname varchar(10), userid int, primary key (id),constraint fk_userid_id foreign key (userid) references users(id)) engine=myisam;
Query OK, 0 rows affected (0.01 sec)

mysql> insert into books values (1,'book1',1);
Query OK, 1 row affected (0.01 sec)
```

​		如果用innodb存储引擎的创建表的话，外键就会起作用，具体如下：

```mysql
mysql> create table users(id int,name varchar(10), primary key (id)) engine=innodb;
Query OK, 0 rows affected (0.02 sec)

mysql> create table books (id int, bookname varchar(10), userid int, primary key (id),constraint fk_userid_id foreign key (userid) references users(id)) engine=innodb;
Query OK, 0 rows affected (0.02 sec)

mysql> insert into books values (1,'book1',1);
ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`test`.`books`, CONSTRAINT `fk_userid_id` FOREIGN KEY (`userid`) REFERENCES `users` (`id`))
```

​		而且，用show create table 命令查看建表语句的时候，发现myisam 存储引擎并不显示外键的语法，而innodb存储引擎就会显示外键语句，具体如下：

```mysql
mysql> show create table books \G;
*************************** 1. row ***************************
       Table: books
Create Table: CREATE TABLE `books` (
  `id` int(11) NOT NULL,
  `bookname` varchar(10) DEFAULT NULL,
  `userid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_userid_id` (`userid`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

mysql> show create table books \G;
*************************** 1. row ***************************
       Table: books
Create Table: CREATE TABLE `books` (
  `id` int(11) NOT NULL,
  `bookname` varchar(10) DEFAULT NULL,
  `userid` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_userid_id` (`userid`),
  CONSTRAINT `fk_userid_id` FOREIGN KEY (`userid`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
1 row in set (0.00 sec)
```

​		

## 15.8 小结

​		SQL优化问题是数据库性能优化最基础也是最重要的一个问题，实践表明很多数据库性能问题都是由不合适的SQL语句造成。