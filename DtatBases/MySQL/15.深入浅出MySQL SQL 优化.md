# 15 SQL 优化

​		在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。



## 15.1 优化 SQL 语句的一般步骤  

​		当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题 。

​		本章大部分涉及的案例表位于MySQL 案例库 Sakila 上。

​		压缩包包括三个文件：sakila-schema.sql 、 sakila-data.sql 和 sakila.mwb ，分别是 Sakila库的表结构创建、数据灌入、Sakila的MySQL Workbench 数据模型（可以在MySQL 工作台打开查看数据库模型）

> Sakila 是一个MySQL 官方提供的模拟电影出租厅信息管理系统的数据库，可以在 https://dev.mysql.com/doc/index-other.html 下载。



### 15.1.1 通过 show status 命令了解各种 SQL 的执行频率  

​		MySQL 客户端连接成功后，通过 show [session|global]status 命令可以提供服务器状态信息，也可以在操作系统上使用 mysqladmin extended-status 命令获得这些消息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”  

​		下面的命令显示了当前 session 中所有统计参数的值：  

```mysql
mysql> show status like 'Com_%';
+-------------------------------------+-------+
| Variable_name                       | Value |
+-------------------------------------+-------+
| Com_admin_commands                  | 0     |
| Com_assign_to_keycache              | 0     |
| Com_alter_db                        | 0     |
| Com_alter_event                     | 0     |
| Com_alter_function                  | 0     |
| Com_alter_instance                  | 0     |
| Com_alter_procedure                 | 0     |
| Com_alter_resource_group            | 0     |
| Com_alter_server                    | 0     |
| Com_alter_table                     | 0     |
| Com_alter_tablespace                | 0     |
...
| Compression                         | OFF   |
+-------------------------------------+-------+
168 rows in set (0.00 sec)
```

​		Com_xxx 表示每个xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。

+ Com_select：执行 SELECT 操作的次数，一次查询只累加1.
+ Com_insert：执行 INSERT 操作的次数，对于批量插入的 INSERT操作，只累加一次。
+ Com_update：执行UPDATE操作的次数
+ Com_delete：执行DELETE操作的次数

​		上面这些参数对于所有存储引擎的表操作都会进行累计。下面这几个参数只是针对 InnoDB 存储引擎的，累加的算法也略有不同。

+ Innodb_rows_read：SELECT查询返回的行数
+ Innodb_rows_inserted：执行INSERT 操作插入的行数。
+ Innodb_rows_updated：执行UPDATE操作更新的行数。
+ Innodb_rows_deleted：执行DELETE 操作删除的行数。

​		通过以上几个参数，可以很容易的了解当前数据库的应用是以插入更新为主还是以查询操作为主，以及各种类型的SQL大致执行比例是多少。对于更新操作的计数，是对执行次数的计数，不论提交还是回滚都会进行累加。

​		对于事务型的应用通过Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。

+ Connections：视图链接MySQL服务器的次数。
+ Uptime：服务器工作时间。
+ Slow_queries：慢查询的次数。



### 15.1.2 定位执行效率较低的 SQL 语句 

​		可以通过以下两种方式定位执行效率较低的 SQL 语句。

1. 通过慢查询日志定位那些执行效率较低的 SQL 语句，将 slow-query-log 参数设置为1之后，MySQL 会将所有执行时间超过 long_query_time 参数所设定阈值的 SQL，写入slow_query_log_file 参数所指定的文件中。
2. 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。  



### 15.1.3 通过 EXPLAIN 分析低效 SQL 的执行计划  

​		通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN 或者 DESC 命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序，比如想统计某个 email 为租赁电影拷贝所支付的总金额，需要关联客户表 customer 和 付款表 payment，并且对付款金额 amount 字段做求和（sum）操作，相应SQL的执行计划如下：

```mysql
mysql> explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 10.00
        Extra: Using where
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.a.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

​		对每个列简单地进行一下说明。

+ select_type：表示 SELECT 的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。
+ table：输出结果集的表。
+ possible_keys：表示查询时可能是用的索引。
+ key：表示实际使用的索引。
+ key_len：使用到索引字段的长度。
+ rows：扫描行的数量。
+ Extra：执行情况的说明和描述，包含不适合在其他列中显示但是对执行计划非常重要的额外信息。
+ filtered：返回结果的行占需要读到的行(rows列的值)的百分比。
+ type：表示MySQL在表中找到所需行的方式，或者叫访问类型，常见的类型有（从上到下，性能由最差到最好）。
  + ALL
  + index
  + range
  + ref
  + eq_ref
  + const,system
  + NULL

（1）type=ALL,全表扫描，MySQL 遍历全表来找到匹配的行：

```mysql
mysql> explain select * from film where rating > 9 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 33.33
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

（2）type=index，索引全扫描，MySQL遍历整个索引来查询匹配的行：

```mysql
mysql> explain select title from film\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_title
      key_len: 514
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)
```

（3）type=range，索引范围扫描，常见于 <,<=,>,>=,between 等操作。

```mysql
mysql> explain select * from payment where customer_id >=300 and customer_id <=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: range
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: NULL
         rows: 1350
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（4）type=ref，使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值得记录行，例如：

```mysql
mysql> explain select * from payment where customer_id=350 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 23
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

​		索引 idx_fk_customer_id 是非唯一索引，查询条件为等值查询条件 customer_id=350,所以扫描索引的类型为ref。ref还经常出现在join操作中：

```mysql
mysql> explain select b.*,a.* from payment a, customer b where a.customer_id=b.customer_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 599
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: sakila.b.customer_id
         rows: 26
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.00 sec)
```

（5）type=eq_ref，类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配；简单来说，就是多表连接中使用 primary key 或者 unique index 作为关联条件。

```mysql
mysql> explain select * from film a, film_text b where a.film_id=b.film_id \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ALL
possible_keys: PRIMARY
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 1000
     filtered: 100.00
        Extra: NULL
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: eq_ref
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 2
          ref: sakila.b.film_id
         rows: 1
     filtered: 100.00
        Extra: Using where
2 rows in set, 1 warning (0.00 sec)
```

> 为什么a是eq_ref,b是all？
>
> 个人理解是因为，a表是使用了主键字段（film_id）去关联b表的主键字段（film_id），所以a表的type=eq_ref, 虽然b表字段 film_id 也是主键，但是需要全表扫描去匹配。

（6）type=const/system，表单中最多有一个匹配行，查询起来非常迅速，所以这个匹配行中的其它列的值可以被优化器在当前查询中当作常量来处理，例如，根据主键 primary key 或者唯一索引 unique index 进行的查询。

​		构造一个查询：

```mysql
mysql> alter table customer add unique index uk_email(email);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from (select * from customer where email='AARON.SELBY@sakilacustomer.org') a \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: customer
   partitions: NULL
         type: const
possible_keys: uk_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)
```

> 注意，教材上还有一条数据，type是system。这里使用的mysql 8.0.16 只有一个const

通过唯一索引 uk_email 访问的时候，类型 type为 const。

（7）type=NULL，MySQL不用访问表或者索引，直接就能够得到结果，例如：

```mysql
mysql> explain select 1 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: NULL
   partitions: NULL
         type: NULL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: NULL
     filtered: NULL
        Extra: No tables used
1 row in set, 1 warning (0.00 sec)
```

​		类型type 还有其它的值，比如 ref_or_null（与ref类似，区别在于条件中包含对NULL的查询）、index_merge（索引合并优化）、unique_subquery（in 的后面是一个查询主键字段的子查询）、index_subquery（与unique_subquery类似，区别在于in的后面是查询非唯一索引字段的子查询）等。



​		MySQL从5.1版本开始支持分区功能，同时 explain 命令也增加了对分区的支持。可以通过explain partitions 命令查看SQL 所访问的分区。例如创建一个Hash分区的 customer_part 表，根据分区键查询的时候，能够看到 explain partitions 的输出结果中有一列 partitions，其中 显示了 SQL 所需要访问的分区名字 p2：

> 数据暂不支持分区，需要安装mysql 并开启分区。

​		有时，仅仅通过 explain 分析执行计划并不能很快地定位 SQL 地问题，那么这时我们还可以选择 profile 联合分析。



### 15.1.4 通过 show profile 分析SQL

​		MySQL 从 5.0.37 版本开始增加了对 show profiles 和 show profile 语句地支持。通过have_profiling 参数，能够看到当前MySQL 是否支持 profile:

```mysql
mysql> select @@have_profiling;
+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+
1 row in set, 1 warning (0.00 sec)
```

​		默认 profiling 是关闭的，可以通过 set 语句在 Session 级别开启 profiling：

```mysql
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.00 sec)
mysql> set profiling=1;
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

​		通过 profile，用户能够更清楚地了解SQL 执行地过程。例如，我们都知道 MyISAM 表有表元数据地缓存（例如行数，即COUNT（\*）值），那么对一个MyISAM 表地 COUNT(\*) 是不需要消耗太多资源地，而对于 InnoDB 来说，就没有这种元数据缓存，COUNT(\*) 就执行的较慢。下面做个实验来验证下。

​		首先，在一个 innodb 引擎地付款表 payment 上，执行一个 COUNT(\*) 查询：

```mysql
mysql> select count(*) from payment;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.03 sec)
```

​		执行完毕后，通过 show profiles 语句，看到当前 SQL 的 Query ID 为 6：

```mysql
mysql> show profiles;
+----------+------------+------------------------------+
| Query_ID | Duration   | Query                        |
+----------+------------+------------------------------+
|        1 | 0.00021950 | select @@profiling           |
|        2 | 0.00698925 | show databases               |
|        3 | 0.00023800 | SELECT DATABASE()            |
|        4 | 0.00642000 | show tables                  |
|        5 | 0.00963100 | show create table payment    |
|        6 | 0.03248600 | select count(*) from payment |
+----------+------------+------------------------------+
6 rows in set, 1 warning (0.00 sec)
```

​		通过 `show profile for query` 语句能够看到执行过程中线程的每个状态和消耗的时间：

```mysql
mysql> show profile for query 6;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000119 |
| Executing hook on transaction  | 0.000004 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000264 |
| init                           | 0.000011 |
| System lock                    | 0.000010 |
| optimizing                     | 0.000005 |
| statistics                     | 0.000016 |
| preparing                      | 0.000030 |
| executing                      | 0.000002 |
| Sending data                   | 0.031881 |
| end                            | 0.000012 |
| query end                      | 0.000004 |
| waiting for handler commit     | 0.000018 |
| closing tables                 | 0.000009 |
| freeing items                  | 0.000081 |
| cleaning up                    | 0.000013 |
+--------------------------------+----------+
18 rows in set, 1 warning (0.00 sec)
```

> 注意：Sending data 状态表示MySQL 线程开始访问数据行并把结果返回给客户端，而不仅仅是返回结果给客户端。由于在 Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。

​		通过仔细检查 `show profile for query` 的输出，能够发现在执行 COUNT(\*) 的过程中，时间主要消耗在 Sending data 这个状态上。为了更清晰地看到排序结果，可以查询 INFORMATION_SCHEMA.PROFILING 表 并按照时间做个 DESC 排序。

```mysql
mysql> set @query_id :=6;
Query OK, 0 rows affected (0.00 sec)

mysql> select 
			state, sum(duration) as total_r, 
			round(100 * sum(duration) / (
        		select sum(duration) from information_schema.profiling where query_id=@query_id
    		), 2) as Pct_R, 
    		count(*) as calls, 
    		sum(duration) / count(*) as 'R/Call' 
    from INFORMATION_SCHEMA.profiling 
    where query_id=@query_id group by state order by total_r desc;
+--------------------------------+----------+-------+-------+--------------+
| state                          | total_r  | Pct_R | calls | R/Call       |
+--------------------------------+----------+-------+-------+--------------+
| Sending data                   | 0.031881 | 98.13 |     1 | 0.0318810000 |
| Opening tables                 | 0.000264 |  0.81 |     1 | 0.0002640000 |
| starting                       | 0.000125 |  0.38 |     2 | 0.0000625000 |
| freeing items                  | 0.000081 |  0.25 |     1 | 0.0000810000 |
| preparing                      | 0.000030 |  0.09 |     1 | 0.0000300000 |
| waiting for handler commit     | 0.000018 |  0.06 |     1 | 0.0000180000 |
| statistics                     | 0.000016 |  0.05 |     1 | 0.0000160000 |
| cleaning up                    | 0.000013 |  0.04 |     1 | 0.0000130000 |
| end                            | 0.000012 |  0.04 |     1 | 0.0000120000 |
| init                           | 0.000011 |  0.03 |     1 | 0.0000110000 |
| System lock                    | 0.000010 |  0.03 |     1 | 0.0000100000 |
| closing tables                 | 0.000009 |  0.03 |     1 | 0.0000090000 |
| optimizing                     | 0.000005 |  0.02 |     1 | 0.0000050000 |
| Executing hook on transaction  | 0.000004 |  0.01 |     1 | 0.0000040000 |
| checking permissions           | 0.000004 |  0.01 |     1 | 0.0000040000 |
| query end                      | 0.000004 |  0.01 |     1 | 0.0000040000 |
| executing                      | 0.000002 |  0.01 |     1 | 0.0000020000 |
+--------------------------------+----------+-------+-------+--------------+
17 rows in set, 18 warnings (0.01 sec)
```

​		在获取到最消耗时间的线程状态后，MySQL 支持进一步选择 all、cpu、block io、context switch、page faults 等明细类型来查看MySQL在使用什么资源上耗费了过高的时间，例如，选择查看CPU 的耗费时间：

```mysql
mysql> show profile cpu for query 6;
+--------------------------------+----------+----------+------------+
| Status                         | Duration | CPU_user | CPU_system |
+--------------------------------+----------+----------+------------+
| starting                       | 0.000119 | 0.000000 |   0.000000 |
| Executing hook on transaction  | 0.000004 | 0.000000 |   0.000000 |
| starting                       | 0.000006 | 0.000000 |   0.000000 |
| checking permissions           | 0.000004 | 0.000000 |   0.000000 |
| Opening tables                 | 0.000264 | 0.000000 |   0.000000 |
| init                           | 0.000011 | 0.000000 |   0.000000 |
| System lock                    | 0.000010 | 0.000000 |   0.000000 |
| optimizing                     | 0.000005 | 0.000000 |   0.000000 |
| statistics                     | 0.000016 | 0.000000 |   0.000000 |
| preparing                      | 0.000030 | 0.000000 |   0.000000 |
| executing                      | 0.000002 | 0.000000 |   0.000000 |
| Sending data                   | 0.031881 | 0.031250 |   0.015625 |
| end                            | 0.000012 | 0.000000 |   0.000000 |
| query end                      | 0.000004 | 0.000000 |   0.000000 |
| waiting for handler commit     | 0.000018 | 0.000000 |   0.000000 |
| closing tables                 | 0.000009 | 0.000000 |   0.000000 |
| freeing items                  | 0.000081 | 0.000000 |   0.000000 |
| cleaning up                    | 0.000013 | 0.000000 |   0.000000 |
+--------------------------------+----------+----------+------------+
18 rows in set, 1 warning (0.00 sec)
```

​		能够发现 Sending data 状态下，时间主要消耗在 CPU上了。

​		对比MyISAM 表的 COUNT(\*) 操作，也创建了一个同样表结构的 MyISAM 表，数据量也完全一致：

```mysql
mysql> create table payment_myisam like payment;
Query OK, 0 rows affected (0.04 sec)

mysql> alter table payment_myisam engine=myisam;
Query OK, 0 rows affected (0.05 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> insert into payment_myisam select * from payment;
Query OK, 16049 rows affected (0.16 sec)
Records: 16049  Duplicates: 0  Warnings: 0
```

​		同样执行 count(\*) 操作，检查 profile :

```mysql
mysql> select count(*) from payment_myisam;
+----------+
| count(*) |
+----------+
|    16049 |
+----------+
1 row in set (0.00 sec)


mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec)

mysql> show profiles \G;
....
*************************** 14. row ***************************
Query_ID: 23
Duration: 0.00027050
   Query: select count(*) from payment_myisam
15 rows in set, 1 warning (0.00 sec)   
 
 
mysql> show profile for query 23;
+--------------------------------+----------+
| Status                         | Duration |
+--------------------------------+----------+
| starting                       | 0.000086 |
| Executing hook on transaction  | 0.000003 |
| starting                       | 0.000006 |
| checking permissions           | 0.000004 |
| Opening tables                 | 0.000030 |
| init                           | 0.000003 |
| System lock                    | 0.000007 |
| optimizing                     | 0.000005 |
| executing                      | 0.000006 |
| end                            | 0.000002 |
| query end                      | 0.000003 |
| closing tables                 | 0.000017 |
| freeing items                  | 0.000067 |
| cleaning up                    | 0.000032 |
+--------------------------------+----------+
14 rows in set, 1 warning (0.00 sec) 
```

​		从 profile 的结果能够看出，InnoDB 引擎的表在 count(\*) 时经历了 Sending data 状态，存在访问数据的过程，而 myisam 引擎的表在 executing 之后直接就结束查询，完全不需要访问数据。

​		show profile 能够在做 SQL 优化时帮助我们了解事件都耗费在哪里去了。而MySQL 5.6 之后则通过 trace 文件进一步向我们展示了优化器是如何执行计划的。

> 注意：在MySQL5.7中，profile 已经不建议使用，而使用 performance schema中的一系列性能视图来替代。



### 15.1.5 通过 trace 分析优化器如何选择执行计划

​		MySQL 从5.6 版本开始提供了对sql的跟踪 trace，通过 trace 文件能够进一步了解为什么优化器选择 A 执行计划而不选择 B执行计划，帮助我们更更好的理解优化器行为。

​		使用方式：首先打开 trace，设置格式为 JSON，设置 trace 最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整显示。

```mysql
mysql> set optimizer_trace='enabled=on', end_markers_in_json=on;
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_trace_max_mem_size=1000000;
Query OK, 0 rows affected (0.00 sec)
```

​		接下来执行想做trace 的sql 语句，例如，想了解租赁表 rental 中库存编号 inventory_id 为 4466 的电影拷贝在出租日期 rental_date 为 2005-05-25 4:00:00 ~5:00:00 出租的记录：

```mysql
mysql> select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466;
+-----------+
| rental_id |
+-----------+
|        39 |
+-----------+
1 row in set (0.02 sec)
```

​		然后检查 INFORMATION_SCHEMA.OPTIMIZER_TRACE 就可以知道 MySQL是如何执行sql语句的：

​		最后会输出一个格式如下的跟踪文件：

```mysql
mysql> select * from information_schema.optimizer_trace\G;
*************************** 1. row ***************************
                            QUERY: select rental_id from rental where 1=1 and rental_date >= '2005-05-25 04:00:00' and rental_date <= '2005-05-25 05:00:00' and inventory_id=4466
                            TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `rental`.`rental_id` AS `rental_id` from `rental` where ((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and (`rental`.`inventory_id` = 4466))",
              "steps": [
                {
                  "transformation": "equality_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "constant_propagation",
                  "resulting_condition": "((`rental`.`rental_date` >= '2005-05-25 04:00:00') and (`rental`.`rental_date` <= '2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                },
                {
                  "transformation": "trivial_condition_removal",
                  "resulting_condition": "((`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00') and multiple equal(4466, `rental`.`inventory_id`))"
                }
              ] /* steps */
            } /* condition_processing */
          },
          {
            "substitute_generated_columns": {
            } /* substitute_generated_columns */
          },
          {
            "table_dependencies": [
              {
                "table": "`rental`",
                "row_may_be_null": false,
                "map_bit": 0,
                "depends_on_map_bits": [
                ] /* depends_on_map_bits */
              }
            ] /* table_dependencies */
          },
          {
            "ref_optimizer_key_uses": [
              {
                "table": "`rental`",
                "field": "inventory_id",
                "equals": "4466",
                "null_rejecting": false
              }
            ] /* ref_optimizer_key_uses */
          },
          {
            "rows_estimation": [
              {
                "table": "`rental`",
                "range_analysis": {
                  "table_scan": {
                    "rows": 16008,
                    "cost": 1699.9
                  } /* table_scan */,
                  "potential_range_indexes": [
                    {
                      "index": "PRIMARY",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "rental_date",
                      "usable": true,
                      "key_parts": [
                        "rental_date",
                        "inventory_id",
                        "customer_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_inventory_id",
                      "usable": true,
                      "key_parts": [
                        "inventory_id",
                        "rental_id"
                      ] /* key_parts */
                    },
                    {
                      "index": "idx_fk_customer_id",
                      "usable": false,
                      "cause": "not_applicable"
                    },
                    {
                      "index": "idx_fk_staff_id",
                      "usable": false,
                      "cause": "not_applicable"
                    }
                  ] /* potential_range_indexes */,
                  "best_covering_index_scan": {
                    "index": "rental_date",
                    "cost": 1629.1,
                    "chosen": true
                  } /* best_covering_index_scan */,
                  "setup_range_conditions": [
                  ] /* setup_range_conditions */,
                  "group_index_range": {
                    "chosen": false,
                    "cause": "not_group_by_or_distinct"
                  } /* group_index_range */,
                  "skip_scan_range": {
                    "potential_skip_scan_indexes": [
                      {
                        "index": "rental_date",
                        "usable": false,
                        "cause": "prefix_not_const_equality"
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "usable": false,
                        "cause": "query_references_nonkey_column"
                      }
                    ] /* potential_skip_scan_indexes */
                  } /* skip_scan_range */,
                  "analyzing_range_alternatives": {
                    "range_scan_alternatives": [
                      {
                        "index": "rental_date",
                        "ranges": [
                          "0x9975b24000 <= rental_date <= 0x9975b25000"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": false,
                        "using_mrr": false,
                        "index_only": true,
                        "rows": 10,
                        "cost": 2.0254,
                        "chosen": true
                      },
                      {
                        "index": "idx_fk_inventory_id",
                        "ranges": [
                          "4466 <= inventory_id <= 4466"
                        ] /* ranges */,
                        "index_dives_for_eq_ranges": true,
                        "rowid_ordered": true,
                        "using_mrr": false,
                        "index_only": false,
                        "rows": 5,
                        "cost": 6.51,
                        "chosen": false,
                        "cause": "cost"
                      }
                    ] /* range_scan_alternatives */,
                    "analyzing_roworder_intersect": {
                      "usable": false,
                      "cause": "too_few_roworder_scans"
                    } /* analyzing_roworder_intersect */
                  } /* analyzing_range_alternatives */,
                  "chosen_range_access_summary": {
                    "range_access_plan": {
                      "type": "range_scan",
                      "index": "rental_date",
                      "rows": 10,
                      "ranges": [
                        "0x9975b24000 <= rental_date <= 0x9975b25000"
                      ] /* ranges */
                    } /* range_access_plan */,
                    "rows_for_plan": 10,
                    "cost_for_plan": 2.0254,
                    "chosen": true
                  } /* chosen_range_access_summary */
                } /* range_analysis */
              }
            ] /* rows_estimation */
          },
          {
            "considered_execution_plans": [
              {
                "plan_prefix": [
                ] /* plan_prefix */,
                "table": "`rental`",
                "best_access_path": {
                  "considered_access_paths": [
                    {
                      "access_type": "ref",
                      "index": "idx_fk_inventory_id",
                      "rows": 5,
                      "cost": 5.5,
                      "chosen": true
                    },
                    {
                      "rows_to_scan": 10,
                      "access_type": "range",
                      "range_details": {
                        "used_index": "rental_date"
                      } /* range_details */,
                      "resulting_rows": 10,
                      "cost": 3.0254,
                      "chosen": true
                    }
                  ] /* considered_access_paths */
                } /* best_access_path */,
                "condition_filtering_pct": 100,
                "rows_for_plan": 10,
                "cost_for_plan": 3.0254,
                "chosen": true
              }
            ] /* considered_execution_plans */
          },
          {
            "attaching_conditions_to_tables": {
              "original_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
              "attached_conditions_computation": [
              ] /* attached_conditions_computation */,
              "attached_conditions_summary": [
                {
                  "table": "`rental`",
                  "attached": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
                }
              ] /* attached_conditions_summary */
            } /* attaching_conditions_to_tables */
          },
          {
            "finalizing_table_conditions": [
              {
                "table": "`rental`",
                "original_table_condition": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))",
                "final_table_condition   ": "((`rental`.`inventory_id` = 4466) and (`rental`.`rental_date` >= TIMESTAMP'2005-05-25 04:00:00') and (`rental`.`rental_date` <= TIMESTAMP'2005-05-25 05:00:00'))"
              }
            ] /* finalizing_table_conditions */
          },
          {
            "refine_plan": [
              {
                "table": "`rental`"
              }
            ] /* refine_plan */
          }
        ] /* steps */
      } /* join_optimization */
    },
    {
      "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
}
MISSING_BYTES_BEYOND_MAX_MEM_SIZE: 0
          INSUFFICIENT_PRIVILEGES: 0
1 row in set (0.01 sec)
```

​		文件里面记录很多信息，包括访问表的路径、行数、成本等，来帮助读者对执行计划的选择过程进行分析。



### 15.1.6 确定文体并采取相应的优化措施

​		经过上面的步骤，基本就可以确认问题出现的原因。此时用户可以根据情况采取相应的措施，进行优化以提高执行的效率。

​		上面某个例子可以确认是由于对客户表 customer 的全表扫描导致效率不理想，那么对客户表 customer 的 email 字段创建索引，具体如下：

```mysql
mysql> create index idx_email on customer(email);
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		创建索引后，再看下这条语句的执行计划，具体如下：

```mysql
mysql>  explain select sum(amount) from customer a,payment b where 1=1 and a.customer_id=b.customer_id and email='JANE.BENNETT@sakilacustomer.org'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: a
   partitions: NULL
         type: const
possible_keys: PRIMARY,uk_email,idx_email
          key: uk_email
      key_len: 203
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
*************************** 2. row ***************************
           id: 1
  select_type: SIMPLE
        table: b
   partitions: NULL
         type: ref
possible_keys: idx_fk_customer_id
          key: idx_fk_customer_id
      key_len: 2
          ref: const
         rows: 28
     filtered: 100.00
        Extra: NULL
2 rows in set, 1 warning (0.01 sec)
```

​		可以发现，建立索引后对客户表 customer 需要扫描的行数明显减少（从599 行减少到1 行）。可见索引的使用可以大大提高数据库的访问速度，尤其在表很庞大的时候，这种优势更为明显。



## 15.2 索引问题

​		索引是数据库优化中最常用也是最重要的手段之一，通过索引通常可以帮助用户解决大多数的SQL性能问题。本节将详细讨论MySQL 中索引的分类、存储和使用方法。

### 15.2.1 索引的存储分类

​		索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型。MySQL目前提供了以下4种索引。

1. B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。
2. HASH索引：只有 Memory/NDB 引擎支持，使用场景简单。
3. R-Tree 索引（空间索引）：空间索引是MyISAM 的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍
4. Full-text（全文索引）：全文索引也是MyISAM 的一个特殊索引类型，主要用于全文索引，InnoDB从MySQL 5.6 版本开始提供对全文索引的支持。

MySQL 目前版本（8.0.11）还不支持函数索引（8.0.13 开始已经支持），但是可以通过两种方式实现函数索引的功能。

（1）前缀索引，即对列的前面某一部分进行索引。例如标题 title 字段，可以只取 title 的前 10 个字符进行索引，这个特性可以大大缩小索引文件的大小，但前缀索引也有缺点，在排序 order by 和 分组 操作的时候无法使用。用户在设计表结构的时候也可以对文本列根据此特性进行灵活设计。

​		下面是创建前缀索引的一个例子：

```mysql
mysql> create index idx_title_1 on film(title(10)) ;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

（2）虚拟列索引。在Oracle 等大多商业数据库种，早已支持函数索引，但MySQL一直没有实现这个功能。在MySQL5.7之后，可以通过创建虚拟列索引的方式来实现函数索引的功能，如下例所示：

​		创建表sql

```mysql
mysql> create table salaries  (emp_no int(11),salary int(11),from_date date, to_date date, primary key (emp_no,from_date));
Query OK, 0 rows affected (0.05 sec)
```



​		在表 salaries 中执行如下 sql

```mysql
mysql> select * from salaries where round(salary/1000) < 10;
```

​		表地定义如下：

```mysql
mysql> desc salaries;
+-----------+---------+------+-----+---------+-------+
| Field     | Type    | Null | Key | Default | Extra |
+-----------+---------+------+-----+---------+-------+
| emp_no    | int(11) | NO   | PRI | NULL    |       |
| salary    | int(11) | YES  |     | NULL    |       |
| from_date | date    | NO   | PRI | NULL    |       |
| to_date   | date    | YES  |     | NULL    |       |
+-----------+---------+------+-----+---------+-------+
4 rows in set (0.00 sec)
```

​		此时，直接在 salary 上创建 索引并不会被这个 sql 使用。这里创建一个虚拟列 salary_by_lk：

```mysql
mysql> alter table salaries add column salary_by_lk int generated always as (round(salary/1000));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

​		然后在这个虚拟列上创建索引：

```mysql
mysql> alter table salaries add key odx_salary_by_lk(salary_by_lk);
Query OK, 0 rows affected (0.03 sec)
```

​		此时观察执行计划，显示新创建的虚拟列索引已经被使用：

```mysql
mysql> desc select count(1) from salaries where round(salary/1000)<10 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: salaries
   partitions: NULL
         type: range
possible_keys: odx_salary_by_lk
          key: odx_salary_by_lk
      key_len: 5
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

```

​		实际执行后，SQL 的执行时间从 8s 降到了 0.2 s。



下面比较MyISAM、InnoDB、Memory 这三个常用引擎支持的索引类型。

| 索引           | MyISAM 引擎 | InnoDB 索引 | Memory 索引 |
| -------------- | ----------- | ----------- | ----------- |
| B-Tree 索引    | 支持        | 支持        | 支持        |
| HASH 索引      | 不支持      | 不支持      | 支持        |
| R-Tree 索引    | 支持        | 不支持      | 不支持      |
| Full-text 索引 | 支持        | 支持        | 不支持      |

​		比较常用到的索引就是 B-Tree 索引和 Hash索引。Hash索引相对简单，只有 Memory/NDB 引擎支持完全的Hash索引，InnoDB 存储引擎在MySQL 5.7 中支持自适应的 Hash索引。所谓自适应，就是MySQL 根据数据的访问频率和模式为某些热点页自动创建Hash索引，索引由 buffer pool 中的B-Tree 来自动生成，效率很高，这个特性由参数 innodb_adaptive_hash_index来控制，默认是打开的。

​		Hash索引适用于 Key-Value 查询，通过Hash索引要比通过B-Tree索引查询更迅速；Hash索引不适用范围查询，例如 <.><=,>= 这类操作。如果使用 Memory/NDB 引擎并且 where 条件不使用 ”=“ 进行索引列，那么就不会用到索引。Memory/Heap 引擎只有在 ”=“ 的条件下才会使用索引。

​		B-Tree 索引比较复杂，下面将详细分析MySQL是如何利用 B-Tree 索引的。



### 15.2.2 MySQL 如何使用索引

​		B-Tree 索引是最常见的索引，构造类似二叉树，能根据键值提供一行或者一个行集的快速访问，通常只需要很少的读操作就可以找到正确的行。不过，需要注意B-Tree索引中的B不代表二叉树（binary），而是代表平衡树（balanced）。B-Tree并不是一颗二叉树。

​		为了避免混淆，重命名租赁表 rental 上的索引 rental_date 为 idx_rental_date:

```mysql
mysql> alter table rental rename index rental_date to idx_rental_date;
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

1. MySQL中能够使用索引的典型场景

   （1）匹配全值（Mathch the full value），对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。例如，租赁表 rental 中通过指定出租日期 rental_date + 库存编号 inventory_id + 客户编号 customer_id 的组合条件 进行查询，从执行计划的 key 和 extra 两个字段的值看到优化器选择了复合索引 idx_rental_date:

   ```mysql
   mysql> explain select * from rental where rental_date='2005-05-25 17:22:10' and inventory_id=373 and customer_id=343 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: const
   possible_keys: idx_rental_date,idx_fk_inventory_id,idx_fk_customer_id
             key: idx_rental_date
         key_len: 10
             ref: const,const,const
            rows: 1
        filtered: 100.00
           Extra: NULL
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		explain 输出结果中字段type的值为const，表示是常量；字段key的值为idx_rental_date,表示优化器选择索引idx_rental_date 进行扫描。

   （2）匹配值的范围查询（Mathch a range of values）,对索引的值能够进行范围查找。例如，检索租赁表 rental中客户编号 customer_id 在指定范围内的记录：

   ```mysql
   mysql> explain select * from rental where customer_id > 373 and customer_id <400 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: rental
      partitions: NULL
            type: range
   possible_keys: idx_fk_customer_id
             key: idx_fk_customer_id
         key_len: 2
             ref: NULL
            rows: 683
        filtered: 100.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ```

   ​		l类型 type 为range 说明优化器选择范围查询，索引 key 为 idx_fx-customer_id 说明优化器选择索引idx_fx_customer_id 来加速访问，注意到这个例子中Extra 列为 Using where，表示优化器除了用索引来加速访问之外，还需要根据索引回表查询数据。

   （3）匹配最左前缀（Match a leftmost prefix），仅仅使用索引中的最左边列进行查找，比如在 col1+col2+col3 字段上的联合索引能够被包含col1、（col1+col2）、（col1+col2+col3） 的等值查询利用到，可是不能够被 col2、（col2+col3）的等值查询利用到；以支付表 payment 为例，如果查询条件中仅包含索引的第一列支付日期 payment_date 和 索引 的第三列更新时间 last_update 的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_last_update的时候，从执行计划的key 和 extra 看到优化器仍然能够使用复合索引 idx_payment_date 进行条件过滤：

   ````mysql
   mysql> alter table payment add index idx_payment_date (payment_date, amount, last_update);
   Query OK, 0 rows affected (0.14 sec)
   Records: 0  Duplicates: 0  Warnings: 0
   
   mysql> explain select * from payment where payment_date='2006-02-14 15:16:03' and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 5
             ref: const
            rows: 182
        filtered: 10.00
           Extra: Using index condition
   1 row in set, 1 warning (0.00 sec)
   
   ERROR:
   No query specified
   ````

   ​		但是，如果仅仅选择复合索引 idx_payment_date 的第二列支付金额amount和 第三列更新时间 last_update_date 进行查询时，那么执行计划显示并不会利用到索引 idx_payment_date:

   ```mysql
   mysql> explain select * from payment where amount = 3.98 and last_update='2006-02-15 22:12:32' \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ALL
   possible_keys: NULL
             key: NULL
         key_len: NULL
             ref: NULL
            rows: 16086
        filtered: 1.00
           Extra: Using where
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		最左匹配原则可以算是 MySQL中B-Tree 索引使用首要原则。

   （4）仅仅对索引进行查询（Index only query），当查询的列都在索引的字段中时，查询的效率更高；对比上一个例子使用 select *, 本次选择查询的字段都包含在索引 idx_payment_date 中时，能够看到查询计划有一点变动：

   ```mysql
   mysql> explain select  last_update from payment where payment_date='2006-02-14 15:16:03' and amount = 3.98 \G;
   *************************** 1. row ***************************
              id: 1
     select_type: SIMPLE
           table: payment
      partitions: NULL
            type: ref
   possible_keys: idx_payment_date
             key: idx_payment_date
         key_len: 8
             ref: const,const
            rows: 8
        filtered: 100.00
           Extra: Using index
   1 row in set, 1 warning (0.00 sec)
   ```

   ​		Extra 部分变成了 Using index ，也就意味着，现在直接访问索引就足够获取到所需要的数据，不需要通过索引回表，Using index 也就是平时说的覆盖索引扫描。只访问必须访问的数据，在一般情况下，减少不必要的数据访问能够提升效率。

（5）匹配列前缀（match a column prefix）,仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。例如，现在需要查询出标题 title 是以 AFRICAN 开头的电影信息，从执行计划能够清楚看到， idx_title_desc_part 索引被利用上了：

```mysql
mysql> create index idx_title_desc_part on film_text (title(10), description(20));
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select title from film_text where title like 'AFRICAN%'\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: film_text
   partitions: NULL
         type: range
possible_keys: idx_title_desc_part,idx_title_description
          key: idx_title_desc_part
      key_len: 42
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using where
1 row in set, 1 warning (0.00 sec)
```

​		Extra 值为 Using where 表示优化器需要通过索引回表查询数据。

（6）能够实现索引匹配部分精确而其他部分进行范围匹配（match one part exactly and match a range on another part）。例如，需要查询出租日期 rental_date 为指定日期且客户编号 customer_id 为指定范围的库存：

```mysql
mysql> explain select inventory_id from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using where; Using index
1 row in set, 1 warning (0.01 sec)
```

​		类型type 为 range 说明优化器选择范围查询，索引 key 为 idx_rental_date 说明优化器选择索引 idx_rental_date 帮助加速查询，同时由于子=只查询索引字段 inventory_id 的值，所以在extra 部分能看到 using index ，表示查询使用了覆盖索引扫描。

（7）如果列名是索引，那么使用 column_name is null 就会使用索引（区别于 Oracle）。例如，查询支付表 payment 的租赁编号 rental_id 字段为空的记录就用到了索引：

```mysql
mysql> explain select * from payment where rental_id is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: payment
   partitions: NULL
         type: ref
possible_keys: fk_payment_rental
          key: fk_payment_rental
      key_len: 5
          ref: const
         rows: 5
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

（8）MySQL5.6引入了 Index Condition Pushdown (ICP) 的特性，进一步优化了查询。Pushdown 表示操作下放，某些情况下的条件过滤操作下放到存储引擎。

​		例如，查询租赁表rental 中租赁时间 rental_date 在某一指定时间点且客户编号 customer_id 在指定范围内的数据，MySQL5.5/5.1的执行计划显示：优化器首先使用复合索引 idx_rental_date 的首字段 rental_date 过滤出符合条件 rental_date='2006-02-14 15:16:03' 的记录（执行计划中的key 字段值显示为 idx_rental_date），然后根据复合索引 idx_rental_date 回表获取记录后，最终根据条件 customer_id >= 300 and customer_id <= 400 来过滤出最后的查询结果（执行计划中 Extra 字段值显示为 Using where）。

```mysql
mysql> select version();
+-----------+
| version() |
+-----------+
| 8.0.16    |
+-----------+
1 row in set (0.00 sec)

mysql> explain select * from rental where rental_date='2006-02-14 15:16:03' and customer_id >= 300 and customer_id <= 400\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: rental
   partitions: NULL
         type: ref
possible_keys: idx_rental_date,idx_fk_customer_id
          key: idx_rental_date
      key_len: 5
          ref: const
         rows: 182
     filtered: 16.85
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)
```

​		MySQL5.7 上做同样的案例，能够发现 Explain 执行计划 的Extra 部分从using where 变成了 Using index condition 的提示

​		Using index condition 表示MySQL使用了ICP 来进一步优化查询，在检索的时候，把条件 customer_id 的过滤操作下推到存储引擎层来完成，这样能够降低不必要的IO访问。

